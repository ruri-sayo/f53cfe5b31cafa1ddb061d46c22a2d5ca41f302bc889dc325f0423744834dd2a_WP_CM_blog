---
layout: post
title: コンピュータの構造（ソフトウェア編）
date:   2025-11-7 19:20:00 +0900
categories: [備忘録, 技術]
description: PCの基礎（ソフトウェア編）です。
---

## はじめに

この記事は「PCの基礎（ハードウェア編）」の続編である。ハードウェアがPCの「体」や「骨格」であるとすれば、今回解説する「ソフトウェア」は、その体を動かす「脳」や「神経」、あるいは「知識」や「技術」そのものである。

ソフトウェアがなければ、どれほど高性能なハードウェアもただの「箱」に過ぎない。この記事では、PCをPCたらしめている「ソフトウェア」とは何か、その種類と役割について詳細に解説する。

## 主なソフトウェア（概要）

まずは、PCを動かしている主要なソフトウェアの分類と、その最低限の役割について解説する。

### OS (オペレーティングシステム)

PCの「土台」となる最も基本的なソフトウェア。ハードウェア（体）を直接管理し、アプリケーション（思考）が動作するための「基盤（OS）」を提供する。Windows, macOS, Linuxなどがこれにあたる。

### アプリケーション (応用ソフトウェア)

OSという土台の上で動作する、特定の「目的」を持ったソフトウェア。「ブラウザ（Web閲覧）」「Officeソフト（文書作成）」「ゲーム」など、ユーザーがPCを使って「やりたいこと」を実現するためのソフトである。

### デバイスドライバ

OS（脳）が、接続された個々のハードウェア（手足や目）の使い方を理解し、制御するための「通訳」ソフトウェア。グラフィックボードやプリンタなど、特定のハードウェア専用に用意される。

### ミドルウェア

OSとアプリケーションの「中間」に位置し、より専門的で共通的な機能を提供するソフトウェア。データベース管理やWebサーバ機能など、OSの基本機能だけでは不足する部分を補う。

## 各ソフトウェアの詳細な解説

### OS (Operating System)

「オペレーティングシステム」は、PCシステム全体を管理する最も重要なソフトウェアである。OSの主な役割は「ハードウェアの抽象化」と「リソース管理」である。

1. **ハードウェアの抽象化 (Abstraction)**
アプリケーション開発者が、世界中に存在する無数のハードウェア（CPU、GPU、ストレージ）の違いを意識せずとも、「ファイルを開く」「画面に文字を出す」といった共通の命令（API、後述）でプログラムを開発できるようにする。OSがハードウェアとの間に入り、複雑な制御を肩代わりする。
2. **リソース管理 (Resource Management)**
PCの限りある資源（リソース）であるCPUパワー、メモリ容量、ストレージ領域を、複数のアプリケーションやプロセスが公平かつ効率的に利用できるように「交通整理」する。

**OSの主要機能**

- **プロセス管理:** 実行中のプログラム（プロセス）の生成・終了・スケジューリング（どのプロセスにいつCPUを使わせるか）を行う。この「スケジューラ」は、優先度に基づいたり、短い時間（タイムスライス）ごとにCPU時間を割り当てたり（ラウンドロビン方式など）して、複数のプロセスが同時に動いているように見せかける。（コラム1参照）
- **メモリ管理:** アプリケーションが互いのメモリ領域を侵害しないよう保護し、物理メモリ（RAM）と仮想メモリ（ストレージ）の割り当てを管理する。（コラム2参照）
- **ファイルシステム管理:** ストレージ（HDD/SSD）上に、データをどのような構造（NTFS, APFS, ext4など）で保存し、どのようにアクセス（読み書き）するかを管理する。現代のファイルシステムの多くは「ジャーナリング機能」を持ち、データの変更履歴を（本体の書き込み前に）一時的に記録することで、不意の電源断時にもデータが壊れにくいよう信頼性を高めている。
- **デバイス管理:** デバイスドライバを通じて、PCに接続されたあらゆるハードウェア（I/Oデバイス）を制御する。

**カーネル (Kernel) と シェル (Shell)**
OSは、その機能によって大きく2つの部分に分けられる。

- **カーネル:** OSの「中核」。ハードウェアの直接制御、プロセス管理、メモリ管理、ファイルシステムといったOSの最も根本的な機能を担う。PC起動時に最初にメモリに読み込まれ、シャットダウンまで常駐する。
    - カーネルの設計思想には「モノリシックカーネル」と「マイクロカーネル」がある。
    - **モノリシックカーネル:** OSの主要機能（プロセス管理、メモリ管理、ファイルシステム、ドライバ）の多くを一つの巨大なプログラム（カーネル空間）で実行する。機能間の連携が高速。Linuxが代表例。
    - **マイクロカーネル:** カーネルの機能を最小限（プロセス間通信、最低限の管理）に留め、ファイルシステムやドライバの多くをカーネル外（ユーザー空間）のプロセスとして実行する。安定性が高いが、機能間連携のオーバーヘッドが大きい。
    - **ハイブリッドカーネル:** 両者の中間。macOS (XNU) や Windows (NTカーネル) は、マイクロカーネル的な設計思想を持ちつつ、性能向上のために一部の機能をカーネル空間に取り込んだハイブリッド型に近い。

[モノリシックカーネルとマイクロカーネルの構造比較図]

- **シェル:** ユーザー（人間）からの指示を受け付け、それをカーネルが理解できる形に翻訳して伝える「窓口」。
    - **CUI (Character User Interface):** 文字（コマンド）で操作するシェル（例：WindowsのコマンドプロンプトやPowerShell、macOS/Linuxのbashやzsh）。
    - **GUI (Graphical User Interface):** マウスやアイコンで直感的に操作するシェル（例：Windowsのエクスプローラー、macOSのFinder）。

**主なOS**

- **Windows:** Microsoftが開発。元々はMS-DOSというCUIベースのOSから発展したが、現在はNT (New Technology) カーネルをベースとしており、高い互換性と豊富なアプリケーション（特にゲーム）で圧倒的なシェアを持つ。
- **macOS:** Appleが開発。NeXTSTEPというUNIX系のOSをベースに開発されており、「UNIX」の認証を受けている（POSIX準拠）。Appleのハードウェアと一体で設計され、安定性が高く、特にクリエイティブ分野で根強い人気を持つ。
- **Linux:** 故リーナス・トーバルズが開発したカーネル、およびそれをベースにしたOS群（ディストリビューション）。UNIXライクなOSであり、オープンソースで開発が進められている。サーバ分野では圧倒的なシェアを持つほか、開発者やエンジニアに好まれる。多種多様な「ディストリビューション」（Ubuntu, Debian, Red Hatなど）が存在する。

### アプリケーション (Application Software)

OSという基盤の上で、ユーザーが特定の作業（文書作成、Web閲覧、画像編集、ゲームなど）を行うために設計されたソフトウェア。

- **ネイティブアプリケーション:** 特定のOS（Windows, macOSなど）専用に開発され、そのOS上で直接実行（インストール）されるアプリ。OSの機能を最大限に活用でき、高速に動作する傾向がある。
- **Webアプリケーション:** ブラウザ上で動作するアプリケーション。OSに依存せず、インターネット経由で利用できる（例：Gmail, Google Docs）。
- **ハイブリッドアプリケーション:** 近年は、Web技術（HTML, CSS, JavaScript）を使いながら、デスクトップアプリとして動作させる技術（例：Electron, Tauri）も普及している。また、Webアプリでありながらネイティブアプリのように動作（オフライン動作、プッシュ通知）するPWA (Progressive Web Apps) も増えている。

### デバイスドライバ (Device Driver)

OS（カーネル）が、特定のハードウェアデバイス（グラフィックボード、サウンドカード、プリンタ、ネットワークカードなど）を認識し、制御するための「通訳」ソフトウェア。
ハードウェアメーカーは、自社製品をOS（例：Windows 11）に対応させるため、専用のデバイスドライバを開発・提供する。OSはこのドライバを通じて、ハードウェアの性能を最大限に引き出す。デバイスドライバはOSのカーネルの一部、またはカーネルと密接に連携して動作するため、不具合があるとシステム全体を不安定にする（ブルースクリーンなど）原因ともなり得る。

### ミドルウェア (Middleware)

OS（基本機能）とアプリケーション（特定目的）の「中間」に位置し、多くのアプリケーションが必要とする共通的かつ高度な機能を提供するソフトウェア。
アプリケーション開発者は、ミドルウェアを利用することで、車輪の再発明（複雑な機能を一から作ること）を避け、自身のアプリケーション本来の機能開発に集中できる。

- **主なミドルウェアの例:**
    - **Webサーバ:** Apache, Nginxなど。HTTPリクエストを受け付け、Webページ（HTMLファイルなど）を返す。
    - **アプリケーションサーバ:** Webサーバと連携し、より複雑な処理（Java, Python, Rubyなどで書かれたプログラム）を実行し、動的なコンテンツを生成する。
    - **データベース管理システム (DBMS):** MySQL, PostgreSQL, Oracle Databaseなど。大量のデータを効率的に管理・検索する機能を提供する。
- **Web3層アーキテクチャ:**
ミドルウェアは、特にWebシステムの構築で重要な役割を果たす。システムを機能ごとに「Webサーバ層」「アプリケーションサーバ(AP)層」「データベース(DB)層」の3層に分離する構成が一般的であり、ミドルウェア（Webサーバ、APサーバ、DBMS）がそれぞれの層を担う。

[Web3層アーキテクチャ（Web/AP/DB）の構成図]

## （コラム）ソフトウェアの動作と仕組み（専門編）

### 1. プログラム、プロセス、スレッド

ハードウェア編で解説したCPUやメモリが、ソフトウェアをどのように扱うのか、その単位を解説する。

- **プログラム (Program):**
特定の処理を行うための命令の集まり。実行可能なファイル（例：`chrome.exe` や `/bin/bash`）として、ストレージ（HDD/SSD）に保存されている状態。これは「設計図」や「レシピ」に例えられる。
- **プロセス (Process):**
ストレージ上にあるプログラムが実行のためにメモリ（RAM）に読み込まれ、OSの管理下に置かれた「実行中の実体」。これは「レシピ（プログラム）に従って、実際に調理（実行）している現場（厨房）」に例えられる。
OSは、プロセスごとに独立したメモリ空間（仮想アドレス空間）を割り当て、他のプロセスから保護する。この「独立性」により、あるプロセスがクラッシュしても他のプロセス（やOS本体）に影響を与えないようになっている。
独立しているが故に、プロセス間でデータをやり取りするには、OSが提供する「プロセス間通信 (IPC)」という特別な仕組み（パイプ、共有メモリ、ソケットなど）が必要となる。
- **スレッド (Thread):**
一つのプロセス内（厨房内）で、実際に処理（調理作業）を行う「実行の最小単位」。「シェフ」に例えられる。
    - **シングルスレッド:** 一つのプロセス（厨房）に一人のシェフ（スレッド）。
    - **マルチスレッド:** 一つのプロセス（厨房）に複数のシェフ（スレッド）。
    **マルチプロセス**（厨房を複数用意する）との違いは、スレッド間ではメモリ空間（調理場や食材）を「共有」している点にある。
    - **メリット:** メモリを共有しているため、スレッド間のデータ連携が容易かつ高速。スレッドの切り替え（コンテキストスイッチ）コストが、プロセスの切り替えに比べて格段に低い。ハードウェア編で解説した「CPUのコア数」が多いほど、この並列処理が効率的に行える。
    - **デメリット:** メモリを共有しているため、複数のスレッドが同時に同じデータ（食材）にアクセスしようとすると、競合状態（排他制御の失敗）が起こりやすく、バグの温床となり得る。

### 2. OSのメモリ管理（仮想メモリ）

物理的なRAM（例：16GB）しか搭載していないPCで、なぜ合計32GBもメモリを消費するような複数のアプリケーションを同時に起動できるのか。その鍵が「仮想メモリ（Virtual Memory）」である。

OSは、各プロセスに対して「PCに搭載されている全メモリ（例：16GB）を自分一人で独占している」かのように見せかける。このプロセスから見える「架空のアドレス空間」を**仮想アドレス空間**と呼ぶ。

この「仮想アドレス」と、実際のRAM上の「物理アドレス」の対応付け（アドレストランスレーション）は、CPUに内蔵された**MMU (Memory Management Unit)** という専用ハードウェアが高速に実行する。

[仮想アドレス空間、MMUによる変換、物理アドレス空間、スワップ領域の関係図]

- **ページング（スワッピング）:**
OSとMMUは、メモリを「ページ」という小さな単位（例：4KB）で管理する。
    1. プロセスがメモリにアクセスしようとすると、MMUはその「仮想アドレス」に対応する「物理アドレス」を探す。
    2. 対応する物理ページがRAM上に見つかれば、そのままアクセスする。
    3. もし対応するページがRAM上に見つからない（まだ読み込まれていない、またはストレージに退避されている）場合、MMUは「**ページフォルト**」という例外を発生させ、CPUはOS（カーネル）を呼び出す。
    4. 呼び出されたOSは、それが正当なアクセスか（不正アクセスならプロセスを強制終了）、ストレージ（スワップファイル）から読み込む必要があるか（**ページイン**）、または物理メモリ（RAM）が一杯で空きを作るために、使われていないページをストレージに退避させる（**ページアウト**）かを判断し、処理を実行する。
    5. ページイン/アウトが完了したら、MMUのアドレス対応表（ページテーブル）を更新し、プロセスは処理を再開する。

この仕組みにより、物理RAMの容量を超える広大なメモリ空間を、OSとストレージの連携によって「仮想的」に実現している。ただし、低速なストレージへのアクセス（ページイン/アウト）が頻発すると、システム全体の動作が極端に遅くなる（**スラッシング**）ため、物理メモリは多いに越したことはない。

### 3. API (Application Programming Interface)

アプリケーション（例：Word）が、OSの機能（例：「ファイルを開く」「印刷する」）を利用するための「関数の呼び出し方」や「データの渡し方」に関する「取り決め（ルール）」。

- **システムコール (System Call):** アプリケーションがOS（カーネル）の機能を呼び出すための、最も基本的なAPI。OSはこのAPIを通じてハードウェアへのアクセスを仲介し、システムを保護する。
- **ライブラリAPI:** システムコールを直接使うのは難解なため、OSや言語が提供する、より使いやすい形の関数群（例：Windows API (Win32 API), macOSのCocoa API, LinuxのPOSIX API, C言語の標準ライブラリ `fopen()` など）。
- **Web API:** 現代では、OSとアプリ間の連携だけでなく、ネットワーク越しに「サービスとサービス」を連携させるためのAPI（主にHTTPベース）も広く使われている。例えば、WebサイトがGoogle Maps APIを利用して地図を表示するなど。

「レストランのウェイター」の例えは、これらのAPIに共通する。客（アプリケーション/サービス）は、厨房（OS/ハードウェア/他サービス）の仕組みを一切知らなくても、メニュー（API仕様書）を見て、ウェイター（API）に「この料理（関数）を注文したい」と伝えるだけで、目的の結果（料理）を得ることができる。

### 4. 機械語、アセンブリ、高級言語

ハードウェア編の「2進数」と「論理回路」に続く話である。CPU（ハードウェア）が直接理解できるのは、「0」と「1」の羅列である「**機械語 (Machine Code)**」だけである。

- **機械語:** `10110000 01100001` (例：MOV AL, 61h)
- **アセンブリ言語 (Assembly):** 機械語と1対1に対応する、人間が少し読みやすい「記号（ニーモニック）」で記述した言語。
`MOV AL, 61h` （ALレジスタに、16進数の61を移動させよ）
- **高級言語 (High-Level Language):** C, C++, Java, Pythonなど。人間が日常言語に近い文法で、抽象的に記述できる言語。
`x = 97;`

人間が書いた高級言語（ソースコード）は、最終的に機械語に「翻訳」されなければCPUで実行できない。その翻訳方式には主に3種類ある。

1. **コンパイラ (Compiler) 方式:**
実行前に、ソースコード全体を一度に解釈・最適化し、すべて機械語（または中間コード）に「一括翻訳」する。
    - **特徴:** 実行速度が非常に速い（実行時は翻訳が不要なため）。
    - **言語:** C, C++, Rust, Go
2. **インタプリタ (Interpreter) 方式:**
ソースコードを1行ずつ「逐次翻訳」しながら、同時に実行していく。
    - **特徴:** 開発が容易（書いたらすぐに実行・修正できる）。
    - **言語:** Python, Ruby, PHP (伝統的な動作)
3. **JIT (Just-In-Time) コンパイラ方式:**
上記2つの中間。実行時にインタプリタとして動作しつつ、頻繁に呼び出される「熱い」コードをその場（Just-In-Time）で検出し、コンパイルして機械語（または最適化された中間コード）に置き換える。
    - **特徴:** インタプリタの手軽さを持ちながら、実行速度はコンパイラ方式に迫る。
    - **言語:** Java (JVM), C# (.NET), JavaScript (V8エンジンなど), Python (PyPy)

**中間コード (Intermediate Code):**
JavaやC#などの言語は、ソースコードを直接特定のCPUの機械語にコンパイルするのではなく、まず「中間コード」（Javaバイトコードや.NET CIL）と呼ばれる仮想的な機械語にコンパイルする。この中間コードを実行環境（JVMやCLR）が、JITコンパイラを使って実行時に各CPUのネイティブな機械語に翻訳する。これにより「一度書けば、どこでも動く (Write Once, Run Anywhere)」というプラットフォーム非依存性を実現している。

[高級言語から機械語への翻訳プロセス（コンパイラ、インタプリタ、JIT）の比較図]