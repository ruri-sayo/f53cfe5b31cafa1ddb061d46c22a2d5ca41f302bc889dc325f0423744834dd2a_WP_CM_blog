<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<!-- 限定公開運用のため既定で noindex -->
<meta name="robots" content="noindex,nofollow">


<title>C#テキスト | 城上コードメモ(v2.1:beta)</title>

<!-- Meta Description -->
<meta name="description"
  content="C#でGUIを学ぶテキスト。初心者向け。">

<!-- ファビコン（最適化済みPNG） -->
<link rel="icon" type="image/png" sizes="32x32" href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/apple-touch-icon.png">

<!-- Tailwind CSS CDN -->
<!--<script src="https://cdn.tailwindcss.com"></script> -->
<script src="https://cdn.tailwindcss.com?plugins=typography"></script>

<!-- お好みでカスタム CSS を足す場合（SCSS を使うなら /assets/css/style.css をビルド）-->
<link rel="stylesheet" href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/assets/css/custom.css">

<!-- イベントモード用CSS -->
<link rel="stylesheet" href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/assets/css/events.css">

<!-- イベントデータ埋め込み -->
<script>
  window.SHIROGAMI_EVENTS = [
    
    {
      id: "newyear",
      name: "正月",
      start_month: 1,
      start_day: 1,
      end_month: 1,
      end_day: 4,
      bg_color: "#FFE4E8",
      header_color: "#C41E3A",
      decoration: "newyear",
      emoji: "🎍"
    },
    
    {
      id: "setsubun",
      name: "節分",
      start_month: 2,
      start_day: 3,
      end_month: 2,
      end_day: 3,
      bg_color: "#FFF5E6",
      header_color: "#8B4513",
      decoration: "setsubun",
      emoji: "👹"
    },
    
    {
      id: "valentine",
      name: "バレンタイン",
      start_month: 2,
      start_day: 14,
      end_month: 2,
      end_day: 14,
      bg_color: "#FFE4EC",
      header_color: "#FF69B4",
      decoration: "valentine",
      emoji: "💝"
    },
    
    {
      id: "aprilfool",
      name: "エイプリルフール",
      start_month: 4,
      start_day: 1,
      end_month: 4,
      end_day: 1,
      bg_color: "#E6FFE6",
      header_color: "#32CD32",
      decoration: "aprilfool",
      emoji: "🤡"
    },
    
    {
      id: "tango",
      name: "端午の節句",
      start_month: 5,
      start_day: 5,
      end_month: 5,
      end_day: 5,
      bg_color: "#E6F0FF",
      header_color: "#4169E1",
      decoration: "tango",
      emoji: "🎏"
    },
    
    {
      id: "tanabata",
      name: "七夕",
      start_month: 7,
      start_day: 7,
      end_month: 7,
      end_day: 7,
      bg_color: "#E6E6FF",
      header_color: "#6A5ACD",
      decoration: "tanabata",
      emoji: "🎋"
    },
    
    {
      id: "obon",
      name: "お盆",
      start_month: 8,
      start_day: 13,
      end_month: 8,
      end_day: 16,
      bg_color: "#F0FFF0",
      header_color: "#228B22",
      decoration: "obon",
      emoji: "🏮"
    },
    
    {
      id: "tsukimi",
      name: "十五夜",
      start_month: 9,
      start_day: 10,
      end_month: 9,
      end_day: 10,
      bg_color: "#FFFACD",
      header_color: "#DAA520",
      decoration: "tsukimi",
      emoji: "🌕"
    },
    
    {
      id: "blog_birthday",
      name: "ブログ誕生日",
      start_month: 10,
      start_day: 16,
      end_month: 10,
      end_day: 16,
      bg_color: "#FFF0F5",
      header_color: "#FF1493",
      decoration: "blog_birthday",
      emoji: "🎂"
    },
    
    {
      id: "halloween",
      name: "ハロウィン",
      start_month: 10,
      start_day: 31,
      end_month: 10,
      end_day: 31,
      bg_color: "#FFF0E6",
      header_color: "#FF8C00",
      decoration: "halloween",
      emoji: "🎃"
    },
    
    {
      id: "christmas",
      name: "クリスマス",
      start_month: 12,
      start_day: 24,
      end_month: 12,
      end_day: 25,
      bg_color: "#FFE4E4",
      header_color: "#C41E3A",
      decoration: "christmas",
      emoji: "🎄"
    }
    
  ];
</script>

<!-- イベントモード用JavaScript -->
<script src="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/assets/js/event-mode.js" defer></script>


<!-- この設定を先に置く（MathJax script の前） -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
    // 必要ならここに他オプション（例: packages 追加 など）
  };
</script>

<!-- MathJax（数式） -->
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<style>
  html {
    scroll-behavior: smooth;
  }
</style>

</head>

<body class="bg-gray-50 text-gray-800">
    <!-- ヘッダー（色付き） -->
    <header class="bg-[#7278a8] text-white shadow-md">
        <div class="container mx-auto px-4 md:px-8 py-4 flex justify-between items-center">
            <h1 class="text-2xl md:text-3xl font-bold">
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/" class="hover:opacity-90 transition-opacity">城上コードメモver2.2</a>
            </h1>
            <!-- デスクトップナビゲーション -->
            <nav class="hidden md:flex space-x-6">
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/" class="text-white/90 hover:text-white transition-colors">ホーム</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/posts/"
                    class="text-white/90 hover:text-white transition-colors">記事一覧</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/tools/"
                    class="text-white/90 hover:text-white transition-colors">ツール一覧</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/novel/"
                    class="text-white/90 hover:text-white transition-colors">Novel</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/game/"
                    class="text-white/90 hover:text-white transition-colors">Game</a>
            </nav>
            <!-- モバイルメニューボタン -->
            <button id="mobile-menu-btn"
                class="md:hidden p-2 rounded-lg hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/50"
                aria-label="メニューを開く" aria-expanded="false">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path id="menu-icon" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
        </div>
    </header>

    <!-- モバイルナビゲーションオーバーレイ -->
    <div id="mobile-menu-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden md:hidden" aria-hidden="true">
    </div>

    <!-- モバイルナビゲーションメニュー -->
    <nav id="mobile-menu"
        class="fixed top-0 right-0 h-full w-64 bg-white shadow-lg z-50 transform translate-x-full transition-transform duration-300 ease-in-out md:hidden"
        aria-label="モバイルナビゲーション">
        <div class="p-4 border-b bg-[#7278a8] text-white flex justify-between items-center">
            <span class="text-lg font-bold">メニュー</span>
            <button id="mobile-menu-close"
                class="p-2 rounded-lg hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/50"
                aria-label="メニューを閉じる">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                    </path>
                </svg>
            </button>
        </div>
        <div class="p-4 space-y-4">
            <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/"
                class="block py-2 px-4 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors">ホーム</a>
            <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/posts/"
                class="block py-2 px-4 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors">記事一覧</a>
            <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/tools/"
                class="block py-2 px-4 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors">ツール一覧</a>
            <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/novel/"
                class="block py-2 px-4 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors">Novel</a>
            <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/game/"
                class="block py-2 px-4 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors">Game</a>
        </div>
    </nav>

    <!-- メインコンテンツ（中央配置・左揃え） -->
    <div class="container mx-auto px-4 md:px-8 py-8">
        <main class="max-w-4xl mx-auto text-left">
            <article class="prose prose-neutral max-w-none">
<header class="mb-6">
<h1 class="text-3xl font-bold">C#テキスト</h1>
<p class="text-gray-500 text-sm">2025-11-18

· <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold">Knowledge</span>

</p>

<p class="text-gray-600 mt-2">C#でGUIを学ぶテキスト。初心者向け。</p>

</header>
<h1 id="第0章-cの世界へようこそ-環境構築と最初のアプリ"><strong>第0章: C#の世界へようこそ (環境構築と最初のアプリ)</strong></h1>

<p>ようこそ。このテキストは、既にPythonなどのプログラミング経験を持つ人が、C#という言語を最短距離で習得し、実用的なGUIアプリケーション（API連携）を構築することを目的としています。</p>

<p>Pythonの柔軟なスクリプティングとは異なる、C#の堅牢なアプリケーション構築の世界を体験していきましょう。</p>

<h2 id="0-1-概念解説-なぜcなのか"><strong>0-1. 【概念解説】 なぜC#なのか？</strong></h2>

<p>最初の疑問は「なぜ今、C#を学ぶのか？」でしょう。特にPythonを知っているなら、なおさらです。C#の立ち位置は、他の言語と比較すると非常に明確です。</p>

<h3 id="cの立ち位置cとpythonのいいとこ取り"><strong>C#の立ち位置：C++とPythonの「いいとこ取り」</strong></h3>

<p>プログラミング言語には、大まかに「実行速度」と「開発効率（書きやすさ）」という2つの軸があります。</p>

<ul>
  <li><strong>C/C++</strong>: ハードウェアに近い制御が可能で、実行速度は最速です。しかし、メモリ管理（ポインタ操作など）が手動であり、開発効率は低く、バグも生みやすい言語です。</li>
  <li><strong>Python</strong>: 文法がシンプルでライブラリも豊富なため、開発効率は最高です。しかし、インタープリタ型であるため、C++と比較すると実行速度は遅くなります。</li>
</ul>

<p>**C#**は、この両者の中間に位置します。</p>

<p>C#は、**C++に迫る「実行速度」**と、**Pythonに近い「開発効率（と安全性）」**を両立させるために設計された言語なのです。</p>

<h3 id="c-vs-c-vs-c速度と安全性の再整理"><strong>C# vs C++ vs C#：速度と安全性の再整理</strong></h3>

<p>よく混同される「C++, C#, C言語」について、ここで明確に整理しましょう。</p>

<ol>
  <li><strong>C / C++ (ネイティブ)</strong>
    <ul>
      <li><strong>速度:</strong> 最速。</li>
      <li><strong>安全性:</strong> <strong>低い（アンセキュア）</strong>。プログラマがメモリを直接操作するため、メモリリークや不正アクセスの危険性が常に伴います。</li>
    </ul>
  </li>
  <li><strong>C# (マネージド)</strong>
    <ul>
      <li><strong>速度:</strong> <strong>非常に高速</strong>。コンパイルによりネイティブコードに近い形で実行されます。Pythonより圧倒的に高速です。</li>
      <li><strong>安全性:</strong> <strong>高い（セキュア）</strong>。ガベージコレクション(GC)という仕組みがメモリを自動で管理し、実行環境(.NETランタイム)が不正な操作を防ぐため、C++のような危険なバグは原理的に発生しにくいです。</li>
    </ul>
  </li>
</ol>

<p>あなたがC#に対して持っていた「比較的遅く、アンセキュア」というイメージは、C#には当てはまりません。むしろC#は**「C++の危険性を排除し、高速実行と開発効率を両立させた言語」**なのです。</p>

<h3 id="このテキストのゴール"><strong>このテキストのゴール</strong></h3>

<p>このテキストでは、C#の文法を一通り学んだ後、以下のアプリケーションを完成させることをゴールとします。</p>

<ul>
  <li><strong>ゴール：C# (WPF) で作る「日本の気象APIビューア」</strong></li>
</ul>

<p>「気象データ」を題材に、C#でAPIを叩き、その結果をGUI（グラフィカル・ユーザー・インターフェース）に表示します。さらに、Pythonと連携させ、データ解析やグラフ化を行うところまでを目指します。</p>

<h2 id="0-2-コード解説-環境構築と-hello-world"><strong>0-2. 【コード解説】 環境構築と “Hello, World”</strong></h2>

<p>C#での開発は、Microsoftが提供する「Visual Studio」という統合開発環境（IDE）で行うのが最も効率的です。</p>

<h3 id="visual-studio-community-のインストール"><strong>Visual Studio Community のインストール</strong></h3>

<ol>
  <li><strong>料金体系の再確認</strong>: Visual Studioにはいくつかのエディションがありますが、私たちは**「Visual Studio Community」<strong>を使用します。これは、個人開発者、学生、オープンソースプロジェクトに対して</strong>無料**で提供されており、有料版とほぼ同等の機能を備えています。</li>
  <li><strong>インストール</strong>: <a href="https://visualstudio.microsoft.com/ja/vs/pricing/">Visual Studio Community 2022のダウンロードページ</a> にアクセスし、インストーラーをダウンロードします。</li>
  <li><strong>ワークロードの選択</strong>: インストーラーを実行すると「ワークロード」（開発分野のセット）の選択画面が表示されます。このテキストでは、まずコンソールアプリ、次にGUIアプリ(WPF)を作成します。
    <ul>
      <li><strong>「.NET デスクトップ開発」</strong> を選択してください。これには、コンソールアプリとWPFの両方に必要なコンポーネントが含まれています。</li>
    </ul>
  </li>
</ol>

<h3 id="最初のコンソールアプリを作成する"><strong>最初の「コンソールアプリ」を作成する</strong></h3>

<p>環境が整ったら、早速最初のプログラムを実行してみましょう。プログラミング学習の伝統に則り、”Hello, World” を表示させます。</p>

<ol>
  <li><strong>Visual Studioの起動</strong>: Visual Studio 2022 を起動し、「新しいプロジェクトの作成」を選択します。</li>
  <li><strong>プロジェクトテンプレートの選択</strong>: 検索ボックスに「コンソール」と入力し、<strong>「コンソールアプリ」</strong>（言語がC#のもの）を選択します。「次へ」を押します。
    <ul>
      <li><em>注意: 「コンソールアプリ (.NET Framework)」という古い選択肢もありますが、新しい標準である「コンソールアプリ」（.NET 8.0など、Core系）を選びます。</em></li>
    </ul>
  </li>
  <li><strong>プロジェクト名の設定</strong>: プロジェクト名を「HelloWorld」など、分かりやすい名前に設定し、「作成」を押します。</li>
  <li><strong>コードの確認</strong>: プロジェクトが作成されると、Program.cs というファイルが自動的に開かれます。最新のC# (.NET 8.0) では、驚くほどシンプルなコードが表示されているはずです。
    <pre><code class="language-C#">// Program.cs  
// このファイルが自動的に開かれます。

// C\# 9以降のトップレベルステートメントにより、これだけで実行可能です。  
Console.WriteLine("Hello, World\!");
</code></pre>
    <p><em>Pythonで言えば、<code class="language-plaintext highlighter-rouge">print("Hello, World\!") </code>と書かれた <code class="language-plaintext highlighter-rouge">.py</code> ファイルをいきなり実行するようなものです。非常に簡潔になりました。</em></p>
  </li>
  <li><strong>実行 (デバッグ開始)</strong>: Visual Studioの上部中央にある緑色の再生ボタン（▶ のアイコン）を押すか、キーボードの F5 キーを押してください。</li>
  <li><strong>結果の確認</strong>: 一瞬、黒いウィンドウ（コンソール）が表示され、Hello, World! と出力された後、すぐにウィンドウが閉じるか、Visual Studioのデバッグコンソールに出力が表示されます。</li>
</ol>

<p>これで、C#プログラムを作成し、実行するまでの流れは完了です。</p>

<h3 id="visual-studioの基本的な使い方"><strong>Visual Studioの基本的な使い方</strong></h3>

<ul>
  <li><strong>ソリューションエクスプローラー</strong>: 画面右側にあるウィンドウで、プロジェクトに含まれるファイル（Program.csなど）を管理します。</li>
  <li><strong>エディタ</strong>: 中央の広い領域がコードを書く場所です。</li>
  <li><strong>デバッグ開始 (F5)</strong>: プログラムを実行し、デバッガをアタッチします。</li>
  <li><strong>デバッグなしで開始 (Ctrl + F5)</strong>: プログラムを実行しますが、デバッガはアタッチしません。コンソールアプリの場合、実行後に「続行するには何かキーを押してください…」というメッセージで停止するため、出力結果を確認しやすいです。</li>
</ul>

<h2 id="0-3-コラム-c-1-visual-studio-vs-visual-studio-code"><strong>0-3. 【コラム】 C-1: Visual Studio vs Visual Studio Code</strong></h2>

<p>Visual Studio Code (VS Code) を使ったことがあるかもしれません。この二つは名前が似ていますが、全く異なるツールです。</p>

<ul>
  <li><strong>Visual Studio Code (VS Code)</strong>
    <ul>
      <li><strong>分類</strong>: 高機能テキストエディタ</li>
      <li><strong>特徴</strong>: 軽量で高速。拡張機能を追加することで、Python, JavaScript, C++など、あらゆる言語に対応できます。C#にも対応できますが、設定は手動の部分が多いです。</li>
      <li><strong>適した用途</strong>: Web開発、スクリプティング、設定ファイルの編集。</li>
    </ul>
  </li>
  <li><strong>Visual Studio (通称 “IDE”)</strong>
    <ul>
      <li><strong>分類</strong>: 統合開発環境 (IDE)</li>
      <li><strong>特徴</strong>: 重量級ですが、C#開発に必要な「すべて」が含まれています。コンパイラ、強力なデバッガ、GUIデザイナー、チーム開発機能などが最初から統合されています。</li>
      <li><strong>適した用途</strong>: C#/.NET開発全般。特に、私たちがこれから学ぶ<strong>WPF（GUI）開発</strong>では、画面の「見た目」をマウスで設計できるビジュアルデザイナー機能が不可欠であり、Visual Studioの独壇場です。</li>
    </ul>
  </li>
</ul>

<p><strong>なぜ今回はVisual Studio (IDE) を使うのか？</strong></p>

<p>答えは、**「WPFのGUIデザイナー」<strong>と</strong>「C#専用の強力なデバッグ・リファクタリング機能」**が必要だからです。</p>

<p>VS Codeが「カスタマイズ可能な万能ナイフ」だとしたら、Visual Studio (IDE) は「C#開発専用に最適化されたハイテクなワークステーション」と言えます。</p>

<h1 id="第1章-cのお作法を掴む-step-1"><strong>第1章: C#の「お作法」を掴む (STEP 1)</strong></h1>

<p>第0章では、C#が「高速」かつ「安全」な言語であること、そして開発環境（Visual Studio）の準備を行いました。</p>

<p>この第1章では、C#の最も基本的な「書き方（お作法）」を学びます。Python既習者の瑠璃さんにとって、Pythonとの違い（特に「型」と「構文の厳密さ」）がC#を理解する鍵となります。</p>

<h2 id="1-1-概念解説-cプログラムの基本構造"><strong>1-1. 【概念解説】 C#プログラムの基本構造</strong></h2>

<p>第0章では、<code>Console.WriteLine("Hello, World\!");</code> だけが書かれた <code class="language-plaintext highlighter-rouge">Program.cs</code> を実行しました。これは最新のC#（トップレベルステートメント）の簡潔な記法です。</p>

<p>しかし、C#の伝統的かつ完全なプログラム構造は、以下の要素で構成されています。</p>
<pre><code class="language-C#">// 伝統的なC\#の "Hello, World"
// 1\. using: Pythonの "import" に相当
using System;

// 2\. namespace: コードの「住所」。Pythonのパッケージ名に近い
namespace HelloWorldApp
{
    // 3\. class: 設計図。すべての実行コードはクラス内に記述する
    class Program
    {
        // 4\. Mainメソッド: プログラムの開始地点（エントリーポイント）
        // Pythonの "if \_\_name\_\_ \== '\_\_main\_\_':" ブロックの役割
        static void Main(string\[\] args)
        {
            Console.WriteLine("Hello, World\!");
        }
    }
}
</code></pre>
<p>トップレベルステートメント（第0章の形式）は、コンパイラが上記のような <code class="language-plaintext highlighter-rouge">Program</code> クラスと <code class="language-plaintext highlighter-rouge">Main</code> メソッドを自動的に補ってくれている、と理解してください。このテキストでは、学習が進むにつれてこの伝統的な形式に移行していきます。</p>

<h3 id="静的型付け言語のメリット"><strong>静的型付け言語のメリット</strong></h3>

<p>C#は<strong>静的型付け言語</strong>です。これは、Python（動的型付け言語）との最大の違いの一つです。</p>

<ul>
  <li><strong>Python (動的型付け)</strong>: 変数の型は、実行時にデータが代入された時点で決まる。
    <pre><code class="language-Python">\# 実行時に型が決まる
temp \= 25.5  \# tempはfloat型
temp \= "hot" \# 今度はstring型。エラーにならない
</code></pre>
  </li>
  <li><strong>C# (静的型付け)</strong>: 変数の型は、**コンパイル時（書いた時点）**に決まっており、変更できない。
    <pre><code class="language-C#">// コンパイル時に型を宣言
double temp \= 25.5; // tempはdouble型 (C\#の標準的な浮動小数点数)
temp \= "hot";       // エラー！ double型の変数にstring型は代入できない
</code></pre>
  </li>
</ul>

<p>C#では、すべての変数に「型」の宣言（<code class="language-plaintext highlighter-rouge">double</code> や <code class="language-plaintext highlighter-rouge">string</code> など）が必須です。これにより、IDE（Visual Studio）がコードを強力にサポートでき、実行する前に「型が違う」というバグを発見できます。これがC#が「安全」で「堅牢」と言われる理由の一つです。</p>

<p>主な基本の型：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int</code>: 整数 (例: <code class="language-plaintext highlighter-rouge">10</code>, <code class="language-plaintext highlighter-rouge">-5</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">double</code>: 浮動小数点数 (例: <code class="language-plaintext highlighter-rouge">25.5</code>, <code class="language-plaintext highlighter-rouge">-3.14</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">string</code>: 文字列 (例: <code class="language-plaintext highlighter-rouge">"Hello"</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">bool</code>: ブール値 (例: <code class="language-plaintext highlighter-rouge">true, false</code>)</li>
</ul>

<h3 id="var-による型推論"><strong><code class="language-plaintext highlighter-rouge">var</code> による型推論</strong></h3>

<p>毎回 <code class="language-plaintext highlighter-rouge">double temp \= 25.5;</code> と書くのは少し冗長です。そこでC#には <code class="language-plaintext highlighter-rouge">var</code> というキーワードがあります。</p>
<pre><code class="language-C#">// var を使うと、コンパイラが右辺から型を自動的に「推論」してくれる
var temp \= 25.5;     // コンパイラが「tempはdouble型」と判断
var name \= "Ruri"; // コンパイラが「nameはstring型」と判断
temp \= "hot";      // エラー！ tempはdouble型と推論されたため、stringは代入不可
</code></pre>
<p>これはPythonの書き方に似ていますが、<strong>意味は全く異なります</strong>。Pythonは実行時に型が変わりますが、C#の var は、あくまで<strong>コンパイル時</strong>に型を決定するための「糖衣構文（シンタックスシュガー）」であり、一度決まった型は変更できません。</p>

<h2 id="1-2-コード解説-基本的な制御とコレクション"><strong>1-2. 【コード解説】 基本的な制御とコレクション</strong></h2>

<h3 id="制御構文-if-for-while"><strong>制御構文 (if, for, while)</strong></h3>

<p>C#の制御構文は、C++やJavaに似ています。Pythonとの主な違いは<code class="language-plaintext highlighter-rouge"> ( )</code> が必須であることと、<code class="language-plaintext highlighter-rouge">: </code>の代わりに <code class="language-plaintext highlighter-rouge">{ } </code>でブロック（範囲）を示すことです。</p>
<pre><code class="language-C#">// if文 (Pythonの elif は C\# では else if)
int temperature \= 30;
if (temperature \&gt;= 30\)
{
    Console.WriteLine("It's hot.");
}
else if (temperature \&lt;= 10\)
{
    Console.WriteLine("It's cold.");
}
else
{
    Console.WriteLine("It's moderate.");
}

// while文 (Pythonとほぼ同じだが、( ) と { } を使う)
int count \= 0;
while (count \&lt; 5\)
{
    Console.WriteLine($"Count is: {count}"); // $"" はPythonのf"" (フォーマット文字列) と同じ
    count++; // count \= count \+ 1 と同じ
}

// C\#の伝統的なfor文 (C++スタイル)
// (初期化; 継続条件; 毎回の処理)
for (int i \= 0; i \&lt; 5; i++)
{
    Console.WriteLine($"i is: {i}");
}
</code></pre>
<h3 id="コレクション-list-dictionary-と-foreach"><strong>コレクション (List, Dictionary) と foreach</strong></h3>

<p>Pythonで <code class="language-plaintext highlighter-rouge">list</code> や <code class="language-plaintext highlighter-rouge">dict</code> を多用したように、C#では <code class="language-plaintext highlighter-rouge">List\&lt;T\&gt;</code> と <code class="language-plaintext highlighter-rouge">Dictionary\&lt;TKey, TValue\&gt; </code>を多用します。<code class="language-plaintext highlighter-rouge">T</code> は「ジェネリクス」と呼ばれ、**「何の」**リスト/辞書なのかを明示します。</p>
<pre><code class="language-C#">// \--- List\&lt;T\&gt; (Pythonの list に相当) \---
// string型 のリストを宣言
List\&lt;string\&gt; skiResorts \= new List\&lt;string\&gt;();

// 要素の追加 (Pythonの .append())
skiResorts.Add("Hakuba");
skiResorts.Add("Niseko");
skiResorts.Add("Zao");

// 要素へのアクセス (Pythonと同じ)
Console.WriteLine(skiResorts\[0\]); // "Hakuba"

// 要素数の取得 (Pythonの len())
Console.WriteLine(skiResorts.Count); // 3

// \--- Dictionary\&lt;TKey, TValue\&gt; (Pythonの dict に相当) \---
// string型 のキーと、 int型 の値を持つ辞書
Dictionary\&lt;string, int\&gt; populations \= new Dictionary\&lt;string, int\&gt;();

// 要素の追加
populations\["Tokyo"\] \= 14000000;
populations\["Osaka"\] \= 2700000;

// 要素へのアクセス
Console.WriteLine(populations\["Tokyo"\]); // 14000000
</code></pre>
<h3 id="foreach-最重要ループ"><strong>foreach (最重要ループ)</strong></h3>

<p>Pythonでは <code class="language-plaintext highlighter-rouge">for item in my\_list: </code>を使ってリストを反復処理しました。C#でこれに最も近いのが <code class="language-plaintext highlighter-rouge">foreach</code> です。C#では、<code class="language-plaintext highlighter-rouge">for (i=0;...) </code>よりも <code class="language-plaintext highlighter-rouge">foreach</code> の方が遥かに多く使われます。</p>
<pre><code class="language-C#">List\&lt;string\&gt; skiResorts \= new List\&lt;string\&gt; { "Hakuba", "Niseko", "Zao" };

// foreach (var 要素 を in コレクション)
foreach (var resort in skiResorts)
{
    // resort は "Hakuba", "Niseko", "Zao" と順に変わる
    Console.WriteLine(resort);
}

// Dictionary の場合
Dictionary\&lt;string, int\&gt; populations \= new Dictionary\&lt;string, int\&gt;
{
    { "Tokyo", 14000000 },
    { "Osaka", 2700000 }
};

// Pythonの .items() に近い
foreach (var pair in populations)
{
    // pair は KeyValuePair\&lt;string, int\&gt; 型
    Console.WriteLine($"City: {pair.Key}, Population: {pair.Value}");
}
</code></pre>
<h2 id="1-3-練習問題"><strong>1-3. 【練習問題】</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Program.cs</code> ファイルを開き、既存のコードをすべて削除した後、以下のコードを貼り付けて実行し、C#の基本を体感してみましょう。</p>

<p><strong>Q1-1: 1週間の平均気温の計算</strong></p>

<p>瑠璃さんの趣味であるスキーに関連して、スキー場の1週間の気温データ（ダミー）があります。</p>

<p><code class="language-plaintext highlighter-rouge">List\&lt;double\&gt;</code> と <code class="language-plaintext highlighter-rouge">foreach </code>ループを使い、これらの合計値と平均気温を計算してコンソールに表示するプログラムを作成してください。</p>
<pre><code class="language-C#">// \--- Q1-1 解答欄 (このコードを Program.cs に貼り付けて実行) \---
// C\#の「お作法」を使うため、usingを宣言
using System;
using System.Collections.Generic; // Listを使うために必要

// 1週間の気温データ
List\&lt;double\&gt; weeklyTemps \= new List\&lt;double\&gt;
{
    \-2.5, 0.0, \-5.0, 1.5, \-3.0, \-1.0, 2.0
};

double sum \= 0.0; // 合計値を初期化

// TODO: foreachループを使って、weeklyTemps の合計値を sum に加算する
foreach (var temp in weeklyTemps)
{
    sum \+= temp; // sum \= sum \+ temp と同じ
}

// TODO: 平均値を計算する (合計値 / 要素数)
// Listの要素数は .Count プロパティで取得できる
double average \= sum / weeklyTemps.Count;

// 結果の表示
Console.WriteLine($"Total sum: {sum}");
Console.WriteLine($"Average temperature: {average}");

// 平均気温を小数点以下2桁で表示 (C\#の書式指定)
Console.WriteLine($"Average (formatted): {average:F2} °C");
</code></pre>
<h2 id="1-4-コラム-c-2-cの型システムとジェネリクス-t"><strong>1-4. 【コラム】 C-2: C#の型システムとジェネリクス (&lt;T&gt;)</strong></h2>

<h3 id="値型-vs-参照型"><strong>値型 vs 参照型</strong></h3>

<p>C#の型には「値型（Value Type）」と「参照型（Reference Type）」の2種類があり、これはC++とPythonの中間のような挙動を示します。</p>

<ul>
  <li><strong>値型</strong>: <code class="language-plaintext highlighter-rouge">int, double, bool, struct</code> など。
    <ul>
      <li>変数自体が**値そのもの（箱）**を保持します。</li>
      <li>代入すると、値が<strong>コピー</strong>されます。
        <pre><code class="language-C#"> int a \= 10;
int b \= a; // aの「値(10)」がbにコピーされる
b \= 20;    // bを変更しても、aは10のまま
</code></pre>
      </li>
    </ul>
  </li>
  <li></li>
  <li><strong>参照型</strong>: <code class="language-plaintext highlighter-rouge">string, List, Dictionary, class</code> など。
    <ul>
      <li>変数は、値が実際に格納されているメモリの**場所（住所）**を保持します。</li>
      <li>代入すると、その<strong>住所</strong>がコピーされます（値そのものはコピーされない）。
        <pre><code class="language-C#"> List\&lt;int\&gt; listA \= new List\&lt;int\&gt; { 1, 2, 3 };
List\&lt;int\&gt; listB \= listA; // listAの「住所」がlistBにコピーされる
listB.Add(4); // listB（が指す先）を変更すると...
// listA\[3\] も 4 になっている (listAとlistBは同じ実体を指しているため)
</code></pre>
      </li>
    </ul>
  </li>
  <li></li>
  <li>Pythonの変数は、すべてこの「参照型」と同じような挙動（オブジェクトへの参照）をします。</li>
</ul>

<h3 id="なぜ-t-ジェネリクス-が必要なのか"><strong>なぜ <code class="language-plaintext highlighter-rouge">\&lt;T\&gt;</code> (ジェネリクス) が必要なのか？</strong></h3>

<p><code class="language-plaintext highlighter-rouge">List\&lt;int\&gt; </code>や<code class="language-plaintext highlighter-rouge"> Dictionary\&lt;string, int\&gt; の \&lt;T\&gt;</code> は<strong>ジェネリクス</strong>と呼ばれ、C#の型安全性を支える非常に重要な機能です。</p>

<p>Pythonのリストは、何でも入れることができます。</p>
<pre><code class="language-Python">my\_list \= \[1, "abc", True\]
</code></pre>
<p>これは柔軟ですが、<code class="language-plaintext highlighter-rouge">my\_list\[1\]</code> から取り出した値が <code class="language-plaintext highlighter-rouge">string </code>であることを忘れて数値計算しようとすると、<strong>実行時</strong>にエラーが発生します。</p>

<p>C#は、これをコンパイル時に防ぎます。</p>
<pre><code class="language-C#">List\&lt;int\&gt; intList \= new List\&lt;int\&gt;();
</code></pre>
<p>と宣言した場合、コンパイラは <code class="language-plaintext highlighter-rouge">intList</code> に対して<code class="language-plaintext highlighter-rouge"> .Add("abc") </code>のような<code class="language-plaintext highlighter-rouge"> string</code> を追加しようとするコードをコンパイルエラーとして弾きます。</p>

<p><code class="language-plaintext highlighter-rouge">List\&lt;T\&gt;</code> の <code class="language-plaintext highlighter-rouge">T</code> は、「このリストは<code class="language-plaintext highlighter-rouge"> T</code> 型のデータ専用です」とコンパイラに教えるための<strong>型プレースホルダー</strong>なのです。これにより、C#は「意図しない型が混入する」という動的型付け言語で起こりがちなバグを、プログラムが実行される前に排除できます。</p>

<h1 id="第2章-cの例外処理とログ基礎">第2章: C#の「例外処理」とログ基礎</h1>

<p>第1章では、C#の基本的な「お作法」（型、変数、コレクション、ループ）を学びました。これだけで、簡単な計算プログラムは作れます。</p>

<p>しかし、実用的なアプリケーション（特に私たちが目指すAPI連携アプリ）を作ろうとすると、必ず「予期せない問題」に直面します。</p>

<ul>
  <li>
    <p>インターネットに接続されていない</p>
  </li>
  <li>
    <p>APIサーバーがダウンしている</p>
  </li>
  <li>
    <p>ユーザーが数字ではなく文字を入力した</p>
  </li>
  <li>
    <p>読み込むべきファイルが存在しない</p>
  </li>
</ul>

<p>このような問題が発生した瞬間にクラッシュする（強制終了する）アプリは、信頼できるものとは言えません。</p>

<p>第2章では、こうした「予期せ”すべき”問題」＝例外 (Exception) に備え、プログラムがクラッシュするのを防ぎ、何が起きたかを記録するための「防御」の技術を学びます。</p>

<h2 id="2-1-概念解説-壊れないアプリのための防御">2-1. 【概念解説】 壊れないアプリのための「防御」</h2>

<h3 id="try-catch-の基本"><strong><code class="language-plaintext highlighter-rouge">try-catch</code> の基本</strong></h3>

<p>C#で例外処理を行う基本構文が<code class="language-plaintext highlighter-rouge"> try-catch </code>です。これはPythonの<code class="language-plaintext highlighter-rouge"> try-except </code>と非常によく似ています。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">try</code> ブロック</strong>: 例外が発生する<strong>可能性のある</strong>処理をこの中に書きます。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">catch</code> ブロック</strong>: try ブロック内で例外が発生した場合に、<strong>実行される</strong>処理（問題の後始末）をこの中に書きます。
    <pre><code class="language-C#">try  
{  
  // 危険な処理 (例: ユーザー入力を数値に変換)  
  // 実行されるが...  
  int number \= int.Parse("abc"); // ここで例外が発生！  
      
  // この行は実行されない  
  Console.WriteLine("Successfully parsed.");  
}  
catch (FormatException e)  
{  
  // 例外が「キャッチ」され、このブロックが実行される  
  Console.WriteLine("Error: Input was not a valid number.");  
  Console.WriteLine($"Exception details: {e.Message}");  
}  
// try-catch ブロックが終了した後、プログラムはここから続行する  
Console.WriteLine("Program continues...");
</code></pre>
    <p>もし<code class="language-plaintext highlighter-rouge"> try-catch </code>がなければ、<code class="language-plaintext highlighter-rouge">int.Parse("abc") </code>の行で<code class="language-plaintext highlighter-rouge"> FormatException </code>という例外が発生し、プログラムは<strong>即座にクラッシュ</strong>していました。<code class="language-plaintext highlighter-rouge">try-catch </code>は、クラッシュを防ぎ、プログラムの実行を継続させるための必須の構文です。</p>
  </li>
</ul>

<h3 id="api通信で出会う主な例外"><strong>API通信で出会う主な例外</strong></h3>

<p>私たちがこれから扱うAPI通信やデータ処理では、以下のような例外に頻繁に出会うことになります。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">HttpRequestException</code></strong>: ネットワーク接続がない、DNS解決に失敗した、サーバーが500エラー（サーバー内部エラー）を返したなど、HTTP通信そのものに失敗した場合に発生します。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">TaskCanceledException</code></strong>: APIサーバーからの応答が遅く、設定した<strong>タイムアウト</strong>時間（例：30秒）を超過した場合に発生します。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">JsonException</code></strong>: APIから送られてきたJSONデータが、C#側で期待していた構造と異なる（例：<code class="language-plaintext highlighter-rouge">int</code> を期待していたのに string が来た）など、JSONの解析（デシリアライズ）に失敗した場合に発生します。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">FormatException</code></strong>: ユーザーが入力した<code class="language-plaintext highlighter-rouge"> string </code>を <code class="language-plaintext highlighter-rouge">int </code>や <code class="language-plaintext highlighter-rouge">double</code> に変換（Parse）しようとして失敗した場合に発生します。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">NullReferenceException</code></strong>: C#開発者が最も恐れる例外。<code class="language-plaintext highlighter-rouge">null</code>（何もない）状態の変数に対して、メソッドを呼び出そうとした場合（例：初期化し忘れた<code class="language-plaintext highlighter-rouge"> List</code> に <code class="language-plaintext highlighter-rouge">.Add() </code>しようとした）に発生します。</li>
</ul>

<h3 id="リソース管理-finally-と-using"><strong>リソース管理 (finally と using)</strong></h3>

<p>例外が発生してもしなくても、<strong>必ず実行したい</strong>処理（例：開いたファイルを閉じる）がある場合があります。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">finally</code></strong>: <code class="language-plaintext highlighter-rouge">try</code> や <code class="language-plaintext highlighter-rouge">catch</code> の処理が終わった後に、<strong>例外の有無にかかわらず必ず実行</strong>されます。
    <pre><code class="language-C#">try { /\* ... \*/ }  
catch { /\* ... \*/ }  
finally  
{  
    // データベース接続を閉じる、ファイルを閉じるなど  
    // 必ず実行したい後始末処理をここに書く  
}
</code></pre>
  </li>
  <li><code class="language-plaintext highlighter-rouge">using</code> 構文: <code class="language-plaintext highlighter-rouge">finally</code> よりも現代的で、推奨される方法です。<br />
<code class="language-plaintext highlighter-rouge">HttpClient</code> やファイルのストリームなど、「使い終わったら破棄 (Dispose) する」必要があるリソース（専門用語で<code class="language-plaintext highlighter-rouge"> IDisposable </code>インターフェースを実装したクラス）を安全に扱うための構文です。
    <pre><code class="language-C#">// この "using" は、第1章の "using System;" とは意味が異なります  
// これは「リソース管理」のための using  
using (var client \= new HttpClient())  
{  
    // ... ここで client を使った処理 ...

} // このブロック { } を抜けた時点で、  
  // client.Dispose() が自動的に呼ばれ、  
  // リソースが安全に解放される (finally相当)
</code></pre>
    <p>この<code class="language-plaintext highlighter-rouge"> using</code> 構文を使うことで、<code class="language-plaintext highlighter-rouge">finally</code> を書き忘れる心配がなくなり、コードが安全かつ簡潔になります。<strong><code class="language-plaintext highlighter-rouge">HttpClient</code> を使う際は、必ず <code class="language-plaintext highlighter-rouge">using</code> 構文を使います。</strong></p>
  </li>
</ul>

<h3 id="ログの重要性"><strong>ログの重要性</strong></h3>

<p>例外を <code class="language-plaintext highlighter-rouge">catch </code>して握りつぶし（無視し）、アプリがクラッシュしないようにするだけでは不十分です。**「なぜエラーが起きたのか」**が開発者に分からなければ、バグを修正できません。</p>

<p>特に私たちが目指すWPF (GUI) アプリでは、<code class="language-plaintext highlighter-rouge">catch</code> されなかった例外は、最終的に「アプリのクラッシュ」として現れますが、<strong><code class="language-plaintext highlighter-rouge">async void</code> 構文（後の章で学習）の内部で発生した例外は、<code class="language-plaintext highlighter-rouge">catch </code>しないと誰にも知られることなく「飲まれ（無視され）」てしまう</strong>危険性があります。</p>

<p>ボタンを押しても何も起こらない。エラーも出ない。これではデバッグのしようがありません。</p>

<p>そこで<strong>ログ (Log)</strong> が重要になります。例外を<code class="language-plaintext highlighter-rouge"> catch</code> したら、その情報を<strong>必ずファイルに書き出す</strong>習慣をつけます。</p>

<ul>
  <li>いつ（タイムスタンプ）</li>
  <li>どこで（クラス名、メソッド名）</li>
  <li>何が起きたか（例外メッセージ、スタックトレース）</li>
</ul>

<p>これらを記録することで、開発者は後からでもバグの原因を追跡できます。</p>

<h2 id="2-2-コード解説-例外を捕まえると記録する"><strong>2-2. 【コード解説】 例外を「捕まえる」と記録する</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Program.cs</code> で、実際にAPI通信の例外を try-catch し、簡易的なログをファイルに出力してみましょう。</p>
<pre><code class="language-C#">// Program.cs

using System;  
using System.Net.Http; // HttpClient を使うために必要  
using System.Threading.Tasks; // Task (非同期) のために必要  
using System.IO; // File (ログ書き込み) のために必要

// C\# 9.0 以降、Mainメソッドも非同期 (async) にできる  
// await を使うために Task を返すようにする  
async Task RunApp()  
{  
    // わざと存在しない、無効なURLを指定する  
    string invalidUrl \= "\[https://invalid-domain.local/api/data\](https://invalid-domain.local/api/data)";  
      
    // ログファイルの名前  
    string logFile \= "app\_log.txt";

    // HttpClientは using 構文で安全に扱う  
    using (var client \= new HttpClient())  
    {  
        try  
        {  
            Console.WriteLine($"Connecting to {invalidUrl} ...");  
              
            // タイムアウトを短く設定 (デモ用)  
            client.Timeout \= TimeSpan.FromSeconds(5);  
              
            // APIにリクエストを送信 (第3章で詳しく解説)  
            string result \= await client.GetStringAsync(invalidUrl);  
              
            Console.WriteLine("Success (this line will not run).");  
        }  
        catch (HttpRequestException e)  
        {  
            // ネットワーク接続エラーやDNSエラーなど  
            Console.WriteLine("Network error occurred\!");  
            LogException(logFile, e);  
        }  
        catch (TaskCanceledException e)  
        {  
            // タイムアウト  
            Console.WriteLine("Request timed out\!");  
            LogException(logFile, e);  
        }  
        catch (Exception e)  
        {  
            // 上記以外のすべての大元の例外 (予期しないエラー)  
            // catch ブロックは、より具体的なものから順に書く  
            Console.WriteLine("An unexpected error occurred\!");  
            LogException(logFile, e);  
        }  
    }  
}

// 簡易的なログ出力メソッド  
void LogException(string filePath, Exception ex)  
{  
    try  
    {  
        // File.AppendAllText は、指定したファイルにテキストを追記する  
        // (ファイルがなければ自動的に作成される)  
        string logMessage \= $"""  
        \=====================================  
        Timestamp: {DateTime.Now}  
        Exception Type: {ex.GetType().Name}  
        Message: {ex.Message}  
        StackTrace:  
        {ex.StackTrace}  
        \=====================================  
        """;  
          
        File.AppendAllText(filePath, logMessage \+ Environment.NewLine);  
          
        Console.WriteLine($"Error details logged to {filePath}");  
    }  
    catch (Exception logEx)  
    {  
        // ログ書き込み自体も失敗する可能性がある (例: 書き込み権限がない)  
        // その場合はコンソールに出力するしかない  
        Console.WriteLine($"FATAL: Failed to write log: {logEx.Message}");  
    }  
}

// アプリケーションの実行  
// RunApp() は Task を返すため、.Wait() で終了を待つ  
RunApp().Wait();
</code></pre>
<p>これを実行すると、コンソールに「Network error occurred!」と表示され、プログラムがクラッシュせずに終了します。<br />
そして、<code class="language-plaintext highlighter-rouge">Program.cs </code>と同じフォルダ（bin/Debug/net8.0など）に <code class="language-plaintext highlighter-rouge">app\_log.txt</code> が作成され、以下のようなエラー詳細が記録されているはずです。</p>
<pre><code class="language-C#">\=====================================  
Timestamp: 2025/11/18 1:23:45  
Exception Type: HttpRequestException  
Message: No such host is known. (invalid-domain.local:443)  
StackTrace:  
   at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(...)  
   ... (以下、詳細な呼び出し履歴) ...  
\=====================================
</code></pre>
<h2 id="2-3-練習問題"><strong>2-3. 【練習問題】</strong></h2>

<p><strong>Q2-1: ユーザー入力の数値変換</strong></p>

<p>ユーザーがコンソールに入力した文字列を<code class="language-plaintext highlighter-rouge"> int </code>型の数値に変換するプログラムを考えます。<br />
しかし、ユーザーが “abc” のような文字列を入力すると <code class="language-plaintext highlighter-rouge">FormatException </code>が発生してクラッシュします。<br />
<code class="language-plaintext highlighter-rouge">try-catch</code>ブロックを使って <code class="language-plaintext highlighter-rouge">FormatException</code> を「捕まえ」、エラーが発生した場合は「”数値で入力してください”」と表示し、プログラムがクラッシュしないようにしてください。</p>
<pre><code class="language-C#">// \--- Q2-1 解答欄 (このコードを Program.cs に貼り付けて実行) \---

using System;

Console.WriteLine("Please enter your age (as a number):");  
string input \= Console.ReadLine(); // ユーザー入力を受け取る

try  
{  
    // TODO: この行は "abc" などを入力すると例外を発生させる  
    int age \= int.Parse(input);  
      
    // 例外が発生しなければ、こちらが実行される  
    Console.WriteLine($"Success\! You are {age} years old.");  
}  
catch (FormatException)  
{  
    // TODO: FormatException が発生した場合の処理をここに書く  
    Console.WriteLine($"Error: '{input}' is not a valid number. Please enter only numbers.");  
}  
catch (Exception ex)  
{  
    // それ以外の予期しないエラー (例: input が null だった場合など)  
    Console.WriteLine($"An unexpected error occurred: {ex.Message}");  
}

Console.WriteLine("Program finished.");
</code></pre>
<h2 id="2-4-コラム-c-3-例外-exceptionはエラー-errorとどう違う"><strong>2-4. 【コラム】 C-3: 「例外 (Exception)」は「エラー (Error)」とどう違う？</strong></h2>

<p>プログラミングにおいて、「例外」と「エラー」は似ていますが、ニュアンスが異なります。</p>

<ul>
  <li><strong>エラー (Error)</strong>:
    <ul>
      <li>プログラムの実行を継続することが<strong>不可能</strong>、あるいは<strong>極めて困難</strong>な、致命的な問題。</li>
      <li>例：メモリ不足 (<code class="language-plaintext highlighter-rouge">OutOfMemoryError</code>)、スタックオーバーフロー (<code class="language-plaintext highlighter-rouge">StackOverflowError</code>)。</li>
      <li>これらは通常、try-catch で<strong>回復（リカバリ）すべきではありません</strong>。プログラムの設計や環境設定そのものを見直す必要があります。</li>
    </ul>
  </li>
  <li><strong>例外 (Exception)</strong>:
    <ul>
      <li>プログラムのロジック自体は正しいものの、実行時の<strong>外的要因</strong>によって発生する「予期すべき問題」。</li>
      <li>例：ファイルが見つからない (<code class="language-plaintext highlighter-rouge">FileNotFoundException</code>)、ネットワークが切断された (<code class="language-plaintext highlighter-rouge">HttpRequestException</code>)、アクセス権がない (<code class="language-plaintext highlighter-rouge">UnauthorizedAccessException</code>)。</li>
      <li>これらは try-catch によって<strong>回復（リカバリ）可能</strong>です。「ファイルが見つからないなら、ユーザーに別の場所を指定してもらう」といった代替処理に移行できます。</li>
    </ul>
  </li>
</ul>

<p>私たちが第2章で扱っているのは、この「例外 (<code class="language-plaintext highlighter-rouge">Exception</code>)」の方です。<br />
C#プログラミングは、「例外は発生するもの」という前提に立ち、それらをいかに堅牢に処理（キャッチ）し、適切に回復させる（またはログに残す）かを設計する作業でもあるのです。</p>

<h1 id="第3章-cでインターネットと話す-非同期apiコール"><strong>第3章: C#でインターネットと話す (非同期APIコール)</strong></h1>

<p>第1章でC#の「お作法」を、第2章で「例外処理」という防御の技術を学びました。これでC#の土台は固まりました。</p>

<p>この第3章から、いよいよアプリケーションの「機能」を作っていきます。私たちが目指す「気象APIビューア」の核となるのは、<strong>インターネット上のサーバーと通信し、データを取得する</strong>機能です。</p>

<p>この章では、C#を使ってインターネットと「会話し」、外部のAPIからデータを取得する強力な方法を学びます。</p>

<h2 id="3-1-概念解説-なぜ非同期処理が必要なのか"><strong>3-1. 【概念解説】 なぜ非同期処理が必要なのか？</strong></h2>

<h3 id="api通信の待ち時間問題"><strong>API通信の「待ち時間」問題</strong></h3>

<p>API (Application Programming Interface) とは、簡単に言えば「外部のサーバーが提供するデータの窓口」です。</p>

<p>C#プログラムがAPIを呼び出す（リクエストを送る）と、サーバーはデータを準備して返信（レスポンスを返す）します。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\[My App\] \--(Request)--\&gt; \[Internet\] \--\&gt; \[API Server\]  
\[My App\] \&lt;-- (Response) \&lt;-- \[Internet\] \&lt;-- \[API Server\]
</code></pre></div></div>
<p>ここで最大の問題は、**「待ち時間」<strong>です。リクエストがサーバーに届き、サーバーがデータを処理し、データがインターネットを経由して返ってくるまでには、コンマ数秒から、場合によっては数十秒の</strong>「待ち時間」**が発生します。</p>

<p>もし、この「待ち時間」の間、プログラム全体が停止（フリーズ）してしまったらどうなるでしょうか？</p>

<ul>
  <li><strong>コンソールアプリ</strong>: 実行が止まり、ユーザーは待たされます。</li>
  <li><strong>GUIアプリ</strong>: <strong>最悪です。</strong> ボタンが押せなくなり、ウィンドウも動かせず、OSから「応答なし」と判断されてしまいます。</li>
</ul>

<p>これを「ブロッキング」と呼びます。</p>

<h3 id="cの切り札-asyncawait"><strong>C#の切り札： <code class="language-plaintext highlighter-rouge">async/await</code></strong></h3>

<p>この「フリーズ地獄」を解決するために、C#には**<code class="language-plaintext highlighter-rouge">async</code> (エイシンク)** と <strong><code class="language-plaintext highlighter-rouge">await</code> (アウェイト)</strong> という、非常に強力で簡潔な「非同期処理」の仕組みが用意されています。</p>

<p>非同期処理とは、「時間がかかる処理（例：API通信）を<strong>OSに発注</strong>し、<strong>自分は待たずに</strong>別の作業（例：GUIの操作）を続け、<strong>発注した処理が終わったら結果を受け取る</strong>」という仕組みです。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">async</code></strong>: メソッドの定義に <code class="language-plaintext highlighter-rouge">async</code> を付けると、「このメソッドは <code class="language-plaintext highlighter-rouge">await</code> を使う非同期メソッドです」と宣言します。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">awai</code>t</strong>: 時間のかかる処理（API通信など）の前に <code class="language-plaintext highlighter-rouge">await </code>を付けると、以下のように動作します。
    <ol>
      <li>OSに「この処理、やっといて」と発注する。</li>
      <li>プログラムの制御を<strong>即座に呼び出し元（例：GUI）に戻す</strong>。</li>
      <li>これにより、GUIはフリーズせずに操作を続けられる。</li>
      <li>発注した処理が完了すると、OSが「終わりました」と通知し、<code class="language-plaintext highlighter-rouge">await</code> の次の行から処理を再開する。</li>
    </ol>
  </li>
</ul>

<p>この<code class="language-plaintext highlighter-rouge"> async/await </code>のおかげで、C#は「フリーズしない、応答性の高いアプリケーション」を非常に簡単に作ることができます。</p>

<h3 id="api通信の核-httpclient"><strong>API通信の核： HttpClient</strong></h3>

<p>C#でHTTP通信（API通信の標準プロトコル）を行うための中心的なクラスが<code class="language-plaintext highlighter-rouge"> HttpClient </code>です。</p>

<p>この <code class="language-plaintext highlighter-rouge">HttpClient</code> は、第2章で学んだ「リソース管理」が必要なクラス（<code class="language-plaintext highlighter-rouge">IDisposable</code>）です。したがって、必ず<code class="language-plaintext highlighter-rouge"> using</code> 構文と共に使います。</p>
<pre><code class="language-C#">// using 構文で HttpClient を安全に扱う  
using (var client \= new HttpClient())  
{  
    // client を使った通信処理  
}
</code></pre>
<h2 id="3-2-コード解説-コンソールでのapiコール実践"><strong>3-2. 【コード解説】 コンソールでのAPIコール実践</strong></h2>

<p><code class="language-plaintext highlighter-rouge">async/await</code> と <code class="language-plaintext highlighter-rouge">HttpClient </code>の使い方を、まずはコンソールアプリでマスターしましょう。</p>

<h3 id="実践1-テストapi-jsonplaceholder"><strong>実践1 (テストAPI): JSONPlaceholder</strong></h3>

<p><code class="language-plaintext highlighter-rouge">JSONPlaceholder </code>は、ダミーのJSONデータを返してくれる、APIテスト用の無料サービスです。</p>
<pre><code class="language-C#">// Program.cs  
// "async" と "Task" を使うことを忘れない  
// usingディレクティブはファイルの先頭にある想定

using System;  
using System.Net.Http;  
using System.Threading.Tasks; // async/await のために必須

async Task RunApp()  
{  
    // 1\. HttpClient を using で初期化  
    using (var client \= new HttpClient())  
    {  
        // 2\. 第2章で学んだ try-catch で防御する  
        try  
        {  
            // 3\. await を使って非同期でAPIを呼び出す  
            //    GetStringAsync は指定したURLから文字列(JSON)を取得する  
            string json \= await client.GetStringAsync("\[https://jsonplaceholder.typicode.com/todos/1\](https://jsonplaceholder.typicode.com/todos/1)");

            Console.WriteLine("API Success\!");  
            Console.WriteLine(json);  
        }  
        catch (HttpRequestException e)  
        {  
            Console.WriteLine($"Network error: {e.Message}");  
        }  
    }  
}

// アプリケーションの実行  
RunApp().Wait();

これを実行すると、以下のようなJSONデータが取得できるはずです。

{  
  "userId": 1,  
  "id": 1,  
  "title": "delectus aut autem",  
  "completed": false  
}
</code></pre>
<h3 id="実践2-github-api-user-agent-の設定"><strong>実践2 (GitHub API): <code class="language-plaintext highlighter-rouge">User-Agent</code> の設定</strong></h3>

<p>APIによっては、<code class="language-plaintext highlighter-rouge">User-Agent</code>（どのアプリがリクエストしているか）の設定が必須の場合があります。GitHub APIがその代表例です。</p>
<pre><code class="language-C#">// Program.cs (RunApp メソッド内を書き換え)

using (var client \= new HttpClient())  
{  
    try  
    {  
        // \--- 実践2の追加点 \---  
        // APIを叩く前に、デフォルトヘッダに User-Agent を設定する  
        // これがないとGitHub APIは 403 Forbidden エラーを返す  
        client.DefaultRequestHeaders.UserAgent.ParseAdd("MyCSharpApp/1.0");  
        // \--- ここまで \---

        string url \= "\[https://api.github.com/repos/dotnet/runtime\](https://api.github.com/repos/dotnet/runtime)";  
        string json \= await client.GetStringAsync(url);

        Console.WriteLine("GitHub API Success\!");  
        Console.WriteLine(json); // dotnet/runtime リポジトリの情報が返る  
    }  
    catch (HttpRequestException e)  
    {  
        Console.WriteLine($"Network error: {e.Message}");  
    }  
}
</code></pre>
<h3 id="実践3-jsonの扱い-オブジェクトへの変換"><strong>実践3 (JSONの扱い): オブジェクトへの変換</strong></h3>

<p>取得したJSONデータは、ただの「文字列」です。このままでは扱いにくいので、C#の<strong>オブジェクト</strong>に変換します。この変換を**デシリアライズ (Deserialize)**と呼びます。</p>

<p>C#には標準で <code class="language-plaintext highlighter-rouge">System.Text.Json</code> というライブラリが用意されています。</p>

<p>まず、JSONの構造に対応するC#の**record**（データ構造を定義する簡易的なクラス）を定義します。</p>
<pre><code class="language-C#">// \--- JSONの構造 \---  
// {  
//   "userId": 1,  
//   "id": 1,  
//   "title": "delectus aut autem",  
//   "completed": false  
// }

// \--- 対応する C\# の record \---  
// (RunApp メソッドの外、または別のファイルに定義)  
// プロパティ名 (UserId, Title) はJSONのキー名 (userId, title) と  
// (大文字小文字を区別せず) 一致させる  
public record class TodoItem(int UserId, int Id, string Title, bool Completed);
</code></pre>
<p>次に、JSON文字列をこの<code class="language-plaintext highlighter-rouge"> TodoItem</code> オブジェクトにデシリアライズします。</p>
<pre><code class="language-C#">// Program.cs (RunApp メソッド内を書き換え)  
// System.Text.Json のための using を追加  
using System.Text.Json;

// (TodoItem の record 定義は別途必要)

using (var client \= new HttpClient())  
{  
    try  
    {  
        string jsonString \= await client.GetStringAsync("\[https://jsonplaceholder.typicode.com/todos/1\](https://jsonplaceholder.typicode.com/todos/1)");  
          
        // \--- 実践3の追加点 \---  
        // JSONのデシリアライズ  
        // オプションでプロパティ名の大文字/小文字を無視する設定(PropertyNameCaseInsensitive)を追加  
        var options \= new JsonSerializerOptions  
        {  
            PropertyNameCaseInsensitive \= true  
        };  
          
        TodoItem? todo \= JsonSerializer.Deserialize\&lt;TodoItem\&gt;(jsonString, options);  
        // \--- ここまで \---

        if (todo \!= null)  
        {  
            // C\#オブジェクトとしてプロパティにアクセスできる！  
            Console.WriteLine("Deserialization Success\!");  
            Console.WriteLine($"Title: {todo.Title}");  
            Console.WriteLine($"Completed: {todo.Completed}");  
        }  
    }  
    catch (HttpRequestException e)  
    {  
        Console.WriteLine($"Network error: {e.Message}");  
    }  
    catch (JsonException e)  
    {  
        // 第2章で学んだ: JSONの解析に失敗した場合の例外  
        Console.WriteLine($"JSON parsing error: {e.Message}");  
    }  
}

// record の定義  
public record class TodoItem(int UserId, int Id, string Title, bool Completed);
</code></pre>
<h2 id="3-3-練習問題"><strong>3-3. 【練習問題】</strong></h2>

<p><strong>Q3-1: Open-Meteo APIで積雪深を取得する</strong></p>

<p>瑠璃さんの趣味であるスキーに関連して、<code class="language-plaintext highlighter-rouge">Open-Meteo</code> APIを使い、特定のスキー場（例：長野県白馬村）の現在の積雪深を取得してみましょう。<br />
第2章で学んだ <code class="language-plaintext highlighter-rouge">try-catch </code>によるエラー処理も必ず実装してください。<br />
<code class="language-plaintext highlighter-rouge">Open-Meteo </code>は <code class="language-plaintext highlighter-rouge">User-Agent</code> が不要で、URLに緯度・経度・取得したい項目を指定します。</p>

<ul>
  <li>API URL (白馬村の緯度経度 + 現在の積雪深): 
`  https://api.open-meteo.com/v1/forecast?latitude=36.70\&amp;longitude=137.86\&amp;current=snowfall  `</li>
  <li><strong>返ってくるJSON (例):</strong>
    <pre><code class="language-C#">{  
  "latitude": 36.7,  
  "longitude": 137.86,  
  "current": {  
    "time": "2025-11-18T00:00",  
    "snowfall": 0.0  
  }  
}
</code></pre>
  </li>
</ul>

<pre><code class="language-C#">// \--- Q3-1 解答欄 (このコードを Program.cs に貼り付けて実行) \---

using System;  
using System.Net.Http;  
using System.Text.Json;  
using System.Threading.Tasks;

// \--- TODO 1: APIのJSON構造に対応する record を定義 \---  
// JSONはネスト(入れ子)になっている点に注意  
// "current" の中に "snowfall" がある

// "current" オブジェクトに対応  
public record class CurrentWeather(double Snowfall);

// 全体のレスポンスに対応  
public record class WeatherResponse(double Latitude, double Longitude, CurrentWeather Current);

// \----------------------------------------------------

async Task RunWeatherApp()  
{  
    string url \= "\[https://api.open-meteo.com/v1/forecast?latitude=36.70\&amp;longitude=137.86\&amp;current=snowfall\](https://api.open-meteo.com/v1/forecast?latitude=36.70\&amp;longitude=137.86\&amp;current=snowfall)";  
      
    using (var client \= new HttpClient())  
    {  
        // \--- TODO 2: try-catch ブロックでAPI通信とJSONデシリアライズを囲む \---  
        try  
        {  
            // 1\. APIからJSON文字列を取得  
            string jsonString \= await client.GetStringAsync(url);  
              
            // 2\. デシリアライズ (大文字/小文字無視)  
            var options \= new JsonSerializerOptions { PropertyNameCaseInsensitive \= true };  
            WeatherResponse? weather \= JsonSerializer.Deserialize\&lt;WeatherResponse\&gt;(jsonString, options);  
              
            // 3\. 結果の表示  
            if (weather \!= null)  
            {  
                Console.WriteLine($"Location: Lat {weather.Latitude}, Lon {weather.Longitude}");  
                // ネストしたオブジェクトのプロパティにアクセス  
                Console.WriteLine($"Current Snowfall: {weather.Current.Snowfall} cm");  
            }  
        }  
        catch (HttpRequestException e)  
        {  
            // ネットワークエラー  
            Console.WriteLine($"Network error: {e.Message}");  
        }  
        catch (JsonException e)  
        {  
            // JSON解析エラー  
            Console.WriteLine($"JSON parsing error: {e.Message}");  
        }  
        catch (Exception e)  
        {  
            // その他すべてのエラー  
            Console.WriteLine($"Unexpected error: {e.Message}");  
        }  
    }  
}

// アプリケーションの実行  
RunWeatherApp().Wait();
</code></pre>
<h2 id="3-4-コラム"><strong>3-4. 【コラム】</strong></h2>

<h3 id="c-4-asyncawait-の裏側-taskとは何か"><strong>C-4: <code class="language-plaintext highlighter-rouge">async/await </code>の裏側 (Taskとは何か？)</strong></h3>

<p>async メソッドが返す <code class="language-plaintext highlighter-rouge">Task</code> (または<code class="language-plaintext highlighter-rouge"> Task\&lt;T\&gt;</code>) とは何でしょうか？</p>

<p>これは「<strong>将来の結果の引換券</strong>」や「<strong>作業伝票</strong>」のようなものです。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GetStringAsync</code> は、<code class="language-plaintext highlighter-rouge">string</code> を直接返すのではなく、<strong><code class="language-plaintext highlighter-rouge">Task\&lt;string\&gt;</code></strong> を返します。</li>
  <li>これは「今すぐには<code class="language-plaintext highlighter-rouge"> string</code> を返せないけど、将来的に<code class="language-plaintext highlighter-rouge"> string</code> を返すことを<strong>約束 (<code class="language-plaintext highlighter-rouge">Task</code>)</strong> する」という意味です。</li>
  <li><code class="language-plaintext highlighter-rouge">await </code>は、この「引換券 (<code class="language-plaintext highlighter-rouge">Task</code>)」を受け取り、結果（<code class="language-plaintext highlighter-rouge">string</code>）が準備できるまでOSに任せて待機し、準備ができたら結果を取り出す演算子です。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">async/await</code> は、この <code class="language-plaintext highlighter-rouge">Task</code> という概念を、C#コンパイラが裏側で（コールバック地獄にならずに）自動的に処理してくれる、非常に強力なシンタックスシュガーなのです。</p>

<h3 id="c-5-rest-api-と-json現代のweb連携のスタンダード"><strong>C-5: REST API と JSON（現代のWeb連携のスタンダード）</strong></h3>

<p>この章で私たちが使った<code class="language-plaintext highlighter-rouge"> JSONPlaceholder</code> や <code class="language-plaintext highlighter-rouge">Open-Meteo</code> は、<strong>REST API</strong> (または RESTful API) と呼ばれる設計思想に基づいています。</p>

<p>これは「Webの仕組み（HTTPプロトコル）を最大限に活用して、シンプルにリソース（データ）を操作しよう」というルールの集まりです。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">https://.../todos/1 </code>のような**URL (URI)**で、操作したいリソース（1番のToDo）を指定する。<br />
*<code class="language-plaintext highlighter-rouge"> GET</code> (取得), <code class="language-plaintext highlighter-rouge">POST</code> (作成), <code class="language-plaintext highlighter-rouge">PUT</code> (更新), <code class="language-plaintext highlighter-rouge">DELETE </code>(削除) といったHTTPメソッドで、操作の種類を伝える。（今回は<code class="language-plaintext highlighter-rouge"> GetStringAsync </code>だったので <code class="language-plaintext highlighter-rouge">GET </code>を使用しました）</li>
</ul>

<p>そして、そのデータの交換形式として、人間にも機械にも読みやすい <strong>JSON (JavaScript Object Notation)</strong> が、XMLに代わって現代のWeb APIの事実上の標準となっています。</p>

<p>この「REST APIを叩いてJSONを取得する」というのが、私たちが作るアプリの基本動作となります。</p>

<h1 id="第4章-wpfでguiアプリケーションを作る-step-3"><strong>第4章: WPFでGUIアプリケーションを作る (STEP 3)</strong></h1>

<p>これまでの章で、私たちはC#の「お作法」（第1章）、堅牢な「例外処理」（第2章）、そして強力な「非同期API通信」（第3章）を学びました。これらはすべて、アプリケーションの「頭脳」や「神経」にあたる部分です。</p>

<p>この第4章では、いよいよアプリケーションの**「顔」<strong>を作ります。C#の得意分野である</strong>WPF (Windows Presentation Foundation)** を使い、これまでコンソールで実行していたAPIコール機能を、ユーザーが操作できる本格的なウィンドウアプリケーションに「アプリケーション化」します。</p>

<h2 id="4-1-概念解説-wpf-windows-presentation-foundation-とは"><strong>4-1. 【概念解説】 WPF (Windows Presentation Foundation) とは？</strong></h2>

<p>WPFは、Microsoftが提供する、Windowsデスクトップアプリケーションの「見た目」と「動作」を作るためのフレームワークです。</p>

<p>WPF開発の最大の特徴は、**「見た目 (XAML)」<strong>と</strong>「ロジック (C#)」**が明確に分離されている点にあります。</p>

<ul>
  <li><strong>XAML (ザムル)</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Extensible Application Markup Language</code> の略。</li>
      <li>ボタン、テキストボックス、グリッドなどの「部品（コントロール）」を、HTML に似たタグ形式で配置し、<strong>GUIの「見た目」を定義</strong>します。</li>
      <li>デザイナーがデザインを担当し、プログラマがロジックを担当する、という分業が容易になります。</li>
    </ul>
  </li>
  <li><strong>コードビハインド (C#)</strong>:<br />
*<code class="language-plaintext highlighter-rouge"> XAML </code>ファイルと1対1で紐づく <code class="language-plaintext highlighter-rouge">*.xaml.cs </code>ファイル。
    <ul>
      <li>「ボタンが押されたら」「テキストが変更されたら」といった**GUIの「動作（ロジック）」**をC#で記述します。</li>
      <li>第3章で私たちが作ったAPI通信のロジックは、このコードビハインドに記述されます。</li>
    </ul>
  </li>
</ul>

<h3 id="主要なコントロール-部品"><strong>主要なコントロール (部品)</strong></h3>

<p>WPFには多くの部品がありますが、最初はこの4つだけ覚えれば十分です。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Grid</code></strong>: 最も基本的なレイアウト用の部品。ウィンドウを格子状（グリッド）に分割し、他の部品を「0行目の1列目」のように配置できます。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Button</code></strong>: ユーザーがクリックできるボタン。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">TextBox</code></strong>: ユーザーが文字を<strong><code class="language-plaintext highlighter-rouge">入力</code></strong>できるテキストボックス。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">TextBloc</code>k</strong>: ユーザーが編集できない、<strong><code class="language-plaintext highlighter-rouge">表示</code></strong>専用のテキストラベル。</li>
</ul>

<h2 id="4-2-コード解説-apiコールアプリのアプリケーション化"><strong>4-2. 【コード解説】 APIコールアプリの「アプリケーション化」</strong></h2>

<p>第3章「実践1」の<code class="language-plaintext highlighter-rouge">JSONPlaceholder</code>を叩くコンソールアプリを、WPFに移植しましょう。</p>

<h3 id="1-wpfプロジェクトの作成"><strong>1. WPFプロジェクトの作成</strong></h3>

<ol>
  <li>Visual Studioを起動し、「新しいプロジェクトの作成」を選択します。</li>
  <li>検索ボックスに「WPF」と入力し、<strong>「WPF アプリケーション」</strong>（C#のもの）を選択します。</li>
  <li>プロジェクト名を <code class="language-plaintext highlighter-rouge">WpfApiApp</code> などと設定し、作成します。</li>
</ol>

<h3 id="2-見た目-xaml-の定義"><strong>2. 見た目 (XAML) の定義</strong></h3>

<p>プロジェクトが作成されると、<code class="language-plaintext highlighter-rouge">MainWindow.xaml </code>というファイルが開かれます。これがメインウィンドウの「見た目」の設計図です。</p>

<p><code class="language-plaintext highlighter-rouge">\&lt;Grid\&gt; </code>タグの内側に、以下のコントロールを配置します。</p>
<pre><code class="language-xaml">&lt;Window x:Class="WpfApiApp.MainWindow"
        xmlns="[http://schemas.microsoft.com/winfx/2006/xaml/presentation](http://schemas.microsoft.com/winfx/2006/xaml/presentation)"
        xmlns:x="[http://schemas.microsoft.com/winfx/2006/xaml](http://schemas.microsoft.com/winfx/2006/xaml)"
        Title="My First WPF API App" Height="350" Width="500"&gt;
    
    &lt;!-- 3行1列のグリッドを定義 --&gt;
    &lt;Grid Margin="10"&gt; &lt;!-- ウィンドウの端から10ピクセルの余白 --&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto" /&gt; &lt;!-- 0行目: コンテンツの高さに自動調整 --&gt;
            &lt;RowDefinition Height="Auto" /&gt; &lt;!-- 1行目: コンテンツの高さに自動調整 --&gt;
            &lt;RowDefinition Height="*" /&gt;    &lt;!-- 2行目: 残りの高さをすべて使う --&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;!-- 0行目: URL入力欄 --&gt;
        &lt;TextBox x:Name="UrlTextBox" Grid.Row="0" Text="[https://jsonplaceholder.typicode.com/todos/1](https://jsonplaceholder.typicode.com/todos/1)" Margin="0,0,0,5" /&gt;

        &lt;!-- 1行目: 取得ボタン --&gt;
        &lt;!-- "Click="GetButton_Click"" で、押されたらC#側の "GetButton_Click" メソッドを呼ぶよう設定 --&gt;
        &lt;Button x:Name="GetButton" Grid.Row="1" Content="データを取得" Click="GetButton_Click" /&gt;

        &lt;!-- 2行目: 結果表示エリア (スクロール可能にする) --&gt;
        &lt;ScrollViewer Grid.Row="2" Margin="0,10,0,0"&gt;
            &lt;TextBlock x:Name="ResultTextBlock" Text="ここに結果が表示されます" TextWrapping="Wrap" /&gt;
        &lt;/ScrollViewer&gt;
        
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>
<h3 id="3-ロジック-c-の記述">3. ロジック (C#) の記述</h3>
<p>MainWindow.xaml に対応する <code class="language-plaintext highlighter-rouge">MainWindow.xaml.cs </code>(ソリューションエクスプローラーで <code class="language-plaintext highlighter-rouge">MainWindow.xaml </code>の下層にある) を開き、ロジックを記述します。</p>
<pre><code class="language-C#">using System;
using System.Net.Http;
using System.Text.Json; // JSONのために追加
using System.Threading.Tasks; // 非同期のために追加
using System.Windows;
using System.Windows.Controls; // TextBlockなどのために追加

namespace WpfApiApp
{
    // JSONデシリアライズ用の record (第3章で定義したもの)
    public record class TodoItem(int UserId, int Id, string Title, bool Completed);

    public partial class MainWindow : Window
    {
        // HttpClientは一度初期化すれば使い回せる (usingで毎回作らない)
        // ※厳密な管理は後の章で学びますが、まずはこれでOK
        private static readonly HttpClient client = new HttpClient();

        public MainWindow()
        {
            InitializeComponent();
        }

        // XAMLで設定した "GetButton_Click" がこれ
        // イベントハンドラは "async void" にするのがお作法
        private async void GetButton_Click(object sender, RoutedEventArgs e)
        {
            // --- 1. ローディング制御 (処理中にボタンを無効化) ---
            GetButton.IsEnabled = false;
            ResultTextBlock.Text = "APIからデータを取得中...";

            // XAMLの "UrlTextBox" からURLを取得
            string url = UrlTextBox.Text;

            // --- 2. 第2章・第3章のロジックを移植 ---
            try
            {
                // APIを非同期で呼び出す
                string jsonString = await client.GetStringAsync(url);

                // JSONをデシリアライズ
                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                TodoItem? todo = JsonSerializer.Deserialize&lt;TodoItem&gt;(jsonString, options);

                // 結果をGUIのTextBlockに表示
                if (todo != null)
                {
                    ResultTextBlock.Text = $"--- 成功 ---\n";
                    ResultTextBlock.Text += $"Title: {todo.Title}\n";
                    ResultTextBlock.Text += $"Completed: {todo.Completed}";
                }
            }
            catch (HttpRequestException ex)
            {
                // エラーメッセージをGUIに表示
                ResultTextBlock.Text = $"--- ネットワークエラー ---\n{ex.Message}";
            }
            catch (JsonException ex)
            {
                // エラーメッセージをGUIに表示
                ResultTextBlock.Text = $"--- JSON解析エラー ---\n{ex.Message}";
            }
            catch (Exception ex)
            {
                // 予期しないエラーをGUIに表示
                ResultTextBlock.Text = $"--- 予期しないエラー ---\n{ex.Message}";
            }
            finally
            {
                // --- 3. ローディング制御 (処理後にボタンを有効化) ---
                // 成功しても失敗しても、必ずボタンを元に戻す
                GetButton.IsEnabled = true;
            }
        }
    }
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">F5</code> キーを押して実行すると、コンソールではなく、デザインしたウィンドウが起動します。「データを取得」ボタンを押すと、<code class="language-plaintext highlighter-rouge">TextBlock</code> の内容がAPIの取得結果（またはエラー）に変わるはずです。</p>

<h2 id="4-3-練習問題">4-3. 【練習問題】</h2>

<p><strong>Q4-1: 「クリア」ボタンの追加</strong></p>

<p>現在のアプリは、結果をクリアする機能がありません。<code class="language-plaintext highlighter-rouge">ResultTextBlock</code> の内容を空にする「クリア」ボタンを追加してください。</p>

<ol>
  <li><strong>XAMLの変更</strong>: <code class="language-plaintext highlighter-rouge">MainWindow.xaml</code> を開き、<code class="language-plaintext highlighter-rouge">GetButton</code> の隣（<code class="language-plaintext highlighter-rouge">Grid</code> の <code class="language-plaintext highlighter-rouge">1行目</code>）に <code class="language-plaintext highlighter-rouge">ClearButton</code> を追加します。（ヒント：<code class="language-plaintext highlighter-rouge">Grid</code> の1行目に2つのボタンを並べるには <code class="language-plaintext highlighter-rouge">StackPanel</code> を使います）</li>
  <li><strong>C#の変更</strong>: <code class="language-plaintext highlighter-rouge">MainWindow.xaml.cs</code> に <code class="language-plaintext highlighter-rouge">ClearButton_Click</code> メソッドを追加し、<code class="language-plaintext highlighter-rouge">ResultTextBlock.Text = "";</code> という処理を記述します。</li>
</ol>

<p><strong>Q4-2: Open-Meteo API (積雪深) の移植</strong></p>

<p><code class="language-plaintext highlighter-rouge">Q3-1</code> で作成した <code class="language-plaintext highlighter-rouge">Open-Meteo</code> の積雪深取得ロジックを、このWPFアプリに移植してください。</p>

<ol>
  <li><strong>C#の変更</strong>: <code class="language-plaintext highlighter-rouge">TodoItem</code> の <code class="language-plaintext highlighter-rouge">record</code> 定義を、<code class="language-plaintext highlighter-rouge">Q3-1</code> で使った <code class="language-plaintext highlighter-rouge">WeatherResponse</code> と <code class="language-plaintext highlighter-rouge">CurrentWeather</code> の <code class="language-plaintext highlighter-rouge">record</code> 定義に置き換えます。</li>
  <li><strong>XAMLの変更</strong>: <code class="language-plaintext highlighter-rouge">UrlTextBox</code> の初期テキストを、<code class="language-plaintext highlighter-rouge">Open-Meteo</code> のURLに変更します。</li>
  <li><strong>C#の変更</strong>: <code class="language-plaintext highlighter-rouge">GetButton_Click</code> メソッド内のデシリアライズ処理 (<code class="language-plaintext highlighter-rouge">JsonSerializer.Deserialize&lt;T&gt;</code>) と、<code class="language-plaintext highlighter-rouge">ResultTextBlock.Text</code> への表示ロジックを、<code class="language-plaintext highlighter-rouge">WeatherResponse</code> オブジェクトから積雪深 (<code class="language-plaintext highlighter-rouge">weather.Current.Snowfall</code>) を表示するように変更します。</li>
</ol>

<h2 id="4-4-コラム-c-6-改訂-wpfのguiスレッドと非同期の罠">4-4. 【コラム】 C-6: (改訂) WPFのGUIスレッドと非同期の罠</h2>

<p>おめでとうございます！あなたは <code class="language-plaintext highlighter-rouge">async void</code> を使った非同期GUIアプリを完成させました。しかし、ここにはWPF初心者が必ず陥る、重大な「罠」が潜んでいます。</p>

<h3 id="1-uiスレッドは1つだけ">1. UIスレッドは1つだけ</h3>

<p>WPFアプリケーションは、「UIスレッド」と呼ばれる<strong>たった1本の糸</strong>で動作しています。ボタンを押す、画面を再描画する、テキストを更新する、といったGUIに関するすべての処理は、この1本の糸が順番に処理しています。</p>

<p>もし、このUIスレッドで<strong>時間がかかる処理</strong>（重い計算や、<strong><code class="language-plaintext highlighter-rouge">await</code> を使わない同期API通信</strong>）を実行すると、どうなるでしょうか？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 【絶対にやってはいけない例】</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">GetButton_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// await を使わず、.Result で「同期的に」結果を待つ</span>
    <span class="c1">// この瞬間、UIスレッドが「結果が返るまで」完全に停止 (フリーズ) する</span>
    <span class="kt">string</span> <span class="n">json</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">UrlTextBox</span><span class="p">.</span><span class="n">Text</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span> 
    
    <span class="n">ResultTextBlock</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">json</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>このコードを実行すると、ボタンを押した瞬間にアプリケーションは完全にフリーズします。OSから「応答なし」と判定され、ウィンドウが白くなります。これが<strong>「フリーズ地獄」</strong>です。<code class="language-plaintext highlighter-rouge">await</code> は、このUIスレッドのフリーズを防ぐために不可欠なのです。</p>

<p>(UIスレッドが同期処理でブロックされ、GUIがフリーズする様子を示す図)</p>

<h3 id="2-async-void-の危険性">2. <code class="language-plaintext highlighter-rouge">async void</code> の危険性</h3>

<p><code class="language-plaintext highlighter-rouge">async void</code> は「<code class="language-plaintext highlighter-rouge">Task</code> を返さない <code class="language-plaintext highlighter-rouge">async</code> メソッド」を意味します。これは「引換券（<code class="language-plaintext highlighter-rouge">Task</code>）を発行しない、やりっぱなしの非同期処理」です。</p>

<p><code class="language-plaintext highlighter-rouge">async void</code> は、<strong>イベントハンドラ（<code class="language-plaintext highlighter-rouge">Button_Click</code> など）で”例外的に”許可されているだけ</strong>です。</p>

<p>なぜなら、<code class="language-plaintext highlighter-rouge">async void</code> メソッド内で <code class="language-plaintext highlighter-rouge">catch</code> されなかった例外は、<strong>呼び出し元が <code class="language-plaintext highlighter-rouge">Task</code> を持っていないため、その例外を検知できず、最終的にアプリケーション全体をクラッシュさせる</strong>（か、環境によっては静かに無視される）からです。</p>

<p><strong>教訓:</strong></p>
<ol>
  <li>メソッドに <code class="language-plaintext highlighter-rouge">async</code> を付けたら、戻り値は <code class="language-plaintext highlighter-rouge">Task</code> または <code class="language-plaintext highlighter-rouge">Task&lt;T&gt;</code> にする。（例: <code class="language-plaintext highlighter-rouge">async Task GetWeatherAsync()</code>）</li>
  <li><code class="language-plaintext highlighter-rouge">async void</code> を使って良いのは、<code class="language-plaintext highlighter-rouge">Button_Click</code> のような<strong>イベントハンドラの最上位</strong>だけ。</li>
</ol>

<h3 id="3-別スレッドからのui更新">3. 別スレッドからのUI更新</h3>

<p><code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> は、処理完了後に自動的にUIスレッドに処理を戻してくれるため、<code class="language-plaintext highlighter-rouge">ResultTextBlock.Text = "..."</code> のように自然にUIを更新できました。</p>

<p>しかし、もし <code class="language-plaintext highlighter-rouge">Task.Run</code> などを使って自分で<strong>別のスレッド（バックグラウンドスレッド）</strong>を起動し、そのスレッドから直接 <code class="language-plaintext highlighter-rouge">ResultTextBlock.Text</code> を更新しようとすると、WPFの安全機構が働き、<strong><code class="language-plaintext highlighter-rouge">InvalidOperationException</code></strong> という例外が発生します。</p>

<p>「UIスレッド（1本）以外のスレッドが、勝手にUI部品（<code class="language-plaintext highlighter-rouge">TextBlock</code>）に触るな！」と怒られるのです。</p>

<p>これを解決するのが <strong><code class="language-plaintext highlighter-rouge">Dispatcher.Invoke</code></strong> ですが、これは <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> を正しく使っていれば、ほとんどの場合不要です。<code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> がいかに優れた仕組みであるかが分かります。</p>

<h1 id="第5章-実践日本の気象apiビューアの構築-step-4"><strong>第5章: 実践！「日本の気象APIビューア」の構築 (STEP 4)</strong></h1>

<p>おめでとうございます！いよいよ最終章です。<br />
これまでの章で、私たちはC#の「お作法」「例外処理」「非同期API」「WPFによるGUI」という4つの強力な武器を手に入れました。<br />
この章は、それら全ての集大成です。瑠璃さんが既にお持ちの「Pythonによるデータ解析」というスキルと、私たちが学んだ「C#による堅牢なGUIアプリケーション」のスキルを**連携（ドッキング）**させ、瑠璃さんの趣味（気象）に特化した、世界に一つだけのアプリケーションを構築します。</p>

<h2 id="5-1-概念解説-プロジェクトの全貌とcpython連携"><strong>5-1. 【概念解説】 プロジェクトの全貌とC#/Python連携</strong></h2>

<h3 id="瑠璃さんのためのテーマ日本の気象apiビューア"><strong>瑠璃さんのためのテーマ：「日本の気象APIビューア」</strong></h3>

<p>私たちが最終的に目指すのは、瑠璃さんの興味（スキー、積雪）に最適化された「日本の気象APIビューア」です。</p>

<h3 id="cとpythonのいいとこ取り"><strong>C#とPythonの「いいとこ取り」</strong></h3>

<p>このプロジェクトの設計思想は、**「両言語の最も得意な部分を活かす」**という点にあります。</p>

<ul>
  <li><strong>C# (WPF) の役割:</strong>
    <ul>
      <li><strong>堅牢なGUI:</strong><code class="language-plaintext highlighter-rouge"> WPF </code>を使い、ユーザーが操作しやすいリッチなデスクトップUIを提供します。（第4章）</li>
      <li><strong>高速・安全なAPI通信:</strong> <code class="language-plaintext highlighter-rouge">async/await </code>と <code class="language-plaintext highlighter-rouge">HttpClient </code>を使い、フリーズしない安全なデータ取得（”神経”）を担当します。（第2章、第3章）</li>
    </ul>
  </li>
  <li><strong>Python の役割:</strong>
    <ul>
      <li><strong>強力なデータ解析:</strong> 瑠璃さんが使い慣れた <code class="language-plaintext highlighter-rouge">pandas</code> ライブラリを使い、C#では手間がかかるデータ集計や操作を行います。</li>
      <li><strong>豊富な可視化:</strong> <code class="language-plaintext highlighter-rouge">matplotlib</code> を使い、C#で複雑な設定をしなくても、簡単に高機能なグラフを生成します。</li>
    </ul>
  </li>
</ul>

<h3 id="連携ドッキングの仕組み"><strong>連携（ドッキング）の仕組み</strong></h3>

<p>C#とPythonという異なる言語をどのように連携させるか？<br />
その答えは、最もシンプルかつ確実な方法である**「ファイル」**を介して行います。<br />
<strong>処理フロー:</strong></p>

<ol>
  <li><strong>[C# GUI]</strong> ユーザーが<code class="language-plaintext highlighter-rouge"> WPF </code>の <code class="language-plaintext highlighter-rouge">TextBox</code> に緯度と経度を入力し、「取得」ボタンを押します。</li>
  <li><strong>[C# Logic]</strong> C#が<code class="language-plaintext highlighter-rouge"> HttpClient </code>で<code class="language-plaintext highlighter-rouge"> Open-Meteo API</code>を非同期で呼び出します。</li>
  <li><strong>[C# → File]</strong> C#は、APIから返ってきた JSON データを、<strong>そのまま</strong>一時ファイル（例: weather_data.json）に書き出します。</li>
  <li><strong>[C# → Python]</strong> C#が <code class="language-plaintext highlighter-rouge">Process.Start </code>を使い、Pythonスクリプト (<code class="language-plaintext highlighter-rouge">analyze.py</code>) をキック（実行）します。</li>
  <li><strong>[Python Script]</strong> <code class="language-plaintext highlighter-rouge">analyze.py </code>が起動し、<code class="language-plaintext highlighter-rouge">weather\_data.json </code>を<code class="language-plaintext highlighter-rouge"> pandas</code> で読み込みます。</li>
  <li><strong>[Python Script]</strong> <code class="language-plaintext highlighter-rouge">pandas</code> でデータを解析（例：積雪深の時系列データを抽出）します。</li>
  <li><strong>[Python → File]</strong> <code class="language-plaintext highlighter-rouge">matplotlib</code> を使ってグラフを生成し、一時ファイル（例: <code class="language-plaintext highlighter-rouge">graph.png</code>）として保存します。</li>
  <li><strong>[Python → C#]</strong> Pythonプロセスが終了します。</li>
  <li><strong>[C# Logic]</strong> C#はPythonプロセスの終了を検知（<code class="language-plaintext highlighter-rouge">WaitForExitAsync</code>）します。</li>
  <li><strong>[File → C# GUI]</strong> C#が <code class="language-plaintext highlighter-rouge">graph.png </code>を<code class="language-plaintext highlighter-rouge"> BitmapImage</code> として読み込み、<code class="language-plaintext highlighter-rouge">WPF</code> の <code class="language-plaintext highlighter-rouge">Image</code> コントロールに表示します。</li>
</ol>

<p>この構成により、C#は面倒なデータ解析をPythonに「丸投げ」でき、PythonはGUI開発をC#に「丸投げ」できる、理想的な分業が成立します。</p>

<h2 id="5-2-コード解説-c-guiとデータ取得"><strong>5-2. 【コード解説】 C# (GUIとデータ取得)</strong></h2>

<p>まず、第4章で作成した<code class="language-plaintext highlighter-rouge"> WpfApiApp </code>プロジェクトを開き、GUI (XAML) とロジック (C#) を改造していきます。</p>

<h3 id="1-gui-mainwindowxaml-の変更"><strong>1. GUI (MainWindow.xaml) の変更</strong></h3>

<p>緯度・経度の入力欄と、グラフを表示するための<code class="language-plaintext highlighter-rouge"> Image</code> コントロールを追加します。</p>

<h3 id="2-ロジック-mainwindowxamlcs-の変更">2. ロジック (MainWindow.xaml.cs) の変更</h3>
<p>これが本プロジェクトのC#側の「心臓部」です。第4章のコードをベースに、APIコール、ファイル書き出し、Pythonプロセス起動、画像読み込みを追加します。</p>

<p>【重要】 <code class="language-plaintext highlighter-rouge">pythonExePath </code>の設定<code class="language-plaintext highlighter-rouge"> MainWindow.xaml.cs</code> 内の <code class="language-plaintext highlighter-rouge">pythonExePath</code> 変数は、瑠璃さんのPCにインストールされている<code class="language-plaintext highlighter-rouge"> python.exe </code>の絶対パスに書き換える必要があります。</p>

<h2 id="5-3-コード解説-python-解析と可視化">5-3. 【コード解説】 Python (解析と可視化)</h2>
<p>次に、C#から呼び出されるPythonスクリプト <code class="language-plaintext highlighter-rouge">analyze.py</code> を作成します。 このファイルは、Visual Studioの「ソリューションエクスプローラー」でWPFプロジェクトを右クリックし、「追加」→「既存の項目」で、プロジェクトの実行ファイル（<code class="language-plaintext highlighter-rouge">bin/Debug/net8.0-windows </code>など）と同じ場所にコピーされるように設定するか、手動で配置します。</p>

<p>（注意：このスクリプトを実行するには、<code class="language-plaintext highlighter-rouge">pandas</code> と <code class="language-plaintext highlighter-rouge">matplotlib</code> が <code class="language-plaintext highlighter-rouge">pip install</code> されている必要があります）</p>
<pre><code class="language-Python">import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import json
import os

# C#が書き出したファイルパス
JSON_INPUT_PATH = "weather_data.json"
GRAPH_OUTPUT_PATH = "graph.png"

def analyze_and_plot():
    try:
        # 1. C#が保存したJSONを読み込む
        with open(JSON_INPUT_PATH, 'r') as f:
            data = json.load(f)

        # 2. pandas で時系列データ(hourly)をDataFrameに変換
        hourly_data = data['hourly']
        df = pd.DataFrame(hourly_data)
        
        # 3. (重要) 時間(time)の列をdatetime型に変換
        # これにより、Matplotlibが時間軸を正しく認識する
        df['time'] = pd.to_datetime(df['time'])
        
        # 欠損値（Noneなど）を0に置換（積雪深がない場合）
        df['snowfall'] = df['snowfall'].fillna(0)
        df['temperature_2m'] = df['temperature_2m'].fillna(0)

        # 4. Matplotlib でグラフを生成
        
        # グラフのフォントが文字化けしないように設定 (日本語を使う場合)
        # plt.rcParams['font.family'] = 'Yu Gothic' # Windowsの場合
        
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # 軸1: 気温 (折れ線グラフ)
        color = 'tab:red'
        ax1.set_xlabel('Date')
        ax1.set_ylabel('Temperature (°C)', color=color)
        ax1.plot(df['time'], df['temperature_2m'], color=color, label='Temperature')
        ax1.tick_params(axis='y', labelcolor=color)
        ax1.grid(True)
        
        # 軸2: 積雪深 (棒グラフ)
        ax2 = ax1.twinx() # 1つ目の軸とX軸を共有
        color = 'tab:blue'
        ax2.set_ylabel('Snowfall (cm)', color=color)
        ax2.bar(df['time'], df['snowfall'], color=color, alpha=0.6, label='Snowfall', width=0.04)
        ax2.tick_params(axis='y', labelcolor=color)
        
        # グラフの体裁を整える
        fig.suptitle(f"Weather Forecast (Lat: {data['latitude']}, Lon: {data['longitude']})", fontsize=16)
        
        # X軸の日付フォーマットを "月/日" に設定
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
        fig.tight_layout(rect=[0, 0.03, 1, 0.95]) # タイトルと重ならないように調整

        # 5. C#が読み込めるようにグラフをファイルに保存
        plt.savefig(GRAPH_OUTPUT_PATH)

    except Exception as e:
        # もしPython側でエラーが起きたら、標準エラー出力に書き出す
        # (C#側はこれを "StandardError.ReadToEndAsync" で検知できる)
        import sys
        print(f"Python Error: {e}", file=sys.stderr)

if __name__ == "__main__":
    analyze_and_plot()
</code></pre>

<hr />

<h2 id="5-4-コード解説-c-結果の表示と仕上げ">5-4. 【コード解説】 C# (結果の表示と仕上げ)</h2>

<p><code class="language-plaintext highlighter-rouge">MainWindow.xaml.cs</code> の <code class="language-plaintext highlighter-rouge">LoadGraphImage</code> メソッドの重要性を再確認します。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (C#コードの再掲)</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">LoadGraphImage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// C#は実行ファイル（.exe）の場所から相対的にファイルを探す</span>
    <span class="c1">// GetFullPathで、OSが認識できる絶対パスに変換する</span>
    <span class="kt">string</span> <span class="n">fullPath</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">GetFullPath</span><span class="p">(</span><span class="n">graphImagePath</span><span class="p">);</span> 

    <span class="k">if</span> <span class="p">(!</span><span class="n">File</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="n">fullPath</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">StatusTextBlock</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">"エラー: グラフファイルが見つかりません。"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// このテクニックがC#とWPFの肝</span>
    <span class="n">BitmapImage</span> <span class="n">bitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BitmapImage</span><span class="p">();</span>
    <span class="n">bitmap</span><span class="p">.</span><span class="nf">BeginInit</span><span class="p">();</span> <span class="c1">// 読み込み開始を宣言</span>
    <span class="n">bitmap</span><span class="p">.</span><span class="n">UriSource</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">fullPath</span><span class="p">,</span> <span class="n">UriKind</span><span class="p">.</span><span class="n">Absolute</span><span class="p">);</span>
    
    <span class="c1">// ★最重要★</span>
    <span class="c1">// OnLoad: 画像をロードした時点でファイルハンドルを解放する</span>
    <span class="c1">// これがないと、C#アプリが "graph.png" を掴み続け、</span>
    <span class="c1">// 次回Pythonが "graph.png" を上書きしようとしたときに</span>
    <span class="c1">// 「Permission Denied (アクセス拒否)」エラーが発生する。</span>
    <span class="n">bitmap</span><span class="p">.</span><span class="n">CacheOption</span> <span class="p">=</span> <span class="n">BitmapCacheOption</span><span class="p">.</span><span class="n">OnLoad</span><span class="p">;</span>
    
    <span class="c1">// キャッシュを無視して、常に最新のファイルを読む</span>
    <span class="n">bitmap</span><span class="p">.</span><span class="n">CreateOptions</span> <span class="p">=</span> <span class="n">BitmapCreateOptions</span><span class="p">.</span><span class="n">IgnoreImageCache</span><span class="p">;</span> 
    
    <span class="n">bitmap</span><span class="p">.</span><span class="nf">EndInit</span><span class="p">();</span> <span class="c1">// 読み込み完了</span>
    <span class="n">bitmap</span><span class="p">.</span><span class="nf">Freeze</span><span class="p">();</span> <span class="c1">// UIスレッド以外からもアクセスできるように「凍結」する</span>

    <span class="n">GraphImage</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="n">bitmap</span><span class="p">;</span> <span class="c1">// WPFのImageコントロールに画像を設定</span>
<span class="p">}</span>
</code></pre></div></div>

<p>これで、C# (WPF) + Python (pandas/matplotlib) の連携アプリケーションが完成です！
<code class="language-plaintext highlighter-rouge">F5</code> を押して実行し、「グラフ生成」ボタンを押してみてください。APIコール、Pythonの解析、そしてグラフ表示までが自動的に行われるはずです。</p>

<hr />

<h2 id="5-5-追加-オプション-pythonを使わない場合のcグラフ可視化">5-5. 【追加】 (オプション) Pythonを使わない場合のC#グラフ可視化</h2>

<p>今回のテキストでは、瑠璃さんのPythonスキルを活かすためにあえて連携させました。しかし、「C#だけで完結させたい」というニーズも当然あります。</p>

<p>C#のエコシステムにも、Pythonの <code class="language-plaintext highlighter-rouge">matplotlib</code> に匹敵する、あるいはそれ以上にWPFに適したグラフライブラリが存在します。</p>

<ul>
  <li><strong>ScottPlot</strong>:
    <ul>
      <li><strong>特徴</strong>: 非常に高速で、インタラクティブな（マウスで操作できる）グラフ描画が得意です。</li>
      <li><strong>WPFとの親和性</strong>: <code class="language-plaintext highlighter-rouge">ScottPlot.WPF</code> という専用のWPFコントロール (<code class="language-plaintext highlighter-rouge">&lt;WpfPlot&gt;</code>) が提供されており、導入が非常に簡単です。</li>
      <li><strong>用途</strong>: 大量の時系列データ（例：センサーデータ）のリアルタイム表示などに最適です。</li>
    </ul>
  </li>
  <li><strong>LiveCharts2</strong>:
    <ul>
      <li><strong>特徴</strong>: モダンで美しく、滑らかなアニメーションが特徴のグラフライブラリです。</li>
      <li><strong>WPFとの親和性</strong>: WPF/MVVMのデータバインディング（本テキストでは扱わなかった上級パターン）と完全に統合するように設計されています。</li>
      <li><strong>用途</strong>: 見た目にこだわるダッシュボードや、リッチなUIのアプリケーションに最適です。</li>
    </ul>
  </li>
  <li><strong>OxyPlot</strong>:
    <ul>
      <li><strong>特徴</strong>: 古くからある定番ライブラリで、非常に多機能かつ堅牢です。</li>
      <li><strong>WPFとの親和性</strong>: WPFコントロールが提供されており、安定した実績があります。</li>
    </ul>
  </li>
</ul>

<p>これらのライブラリを使えば、Pythonに頼らずとも、C#のコード内だけでAPIデータを直接グラフ化することが可能です。Python連携はあくまで「選択肢の一つ」であり、C#は単体でも強力な可視化能力を持っていることを覚えておいてください。</p>

<h2 id="5-6-練習問題">5-6. 【練習問題】</h2>

<p><strong>Q5-1: Pythonからの「解析結果（数値）」の返却</strong></p>

<p>現在はPythonからグラフ画像（<code class="language-plaintext highlighter-rouge">graph.png</code>）のみを受け取っています。
Python側でのみ計算可能な「解析結果」（例：期間中の最高気温）を、C#側の <code class="language-plaintext highlighter-rouge">TextBlock</code> に表示する機能を追加してみましょう。</p>

<ol>
  <li><strong>[Python] (<code class="language-plaintext highlighter-rouge">analyze.py</code>) の変更:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pandas</code> を使って「過去7日間の最高気温」(<code class="language-plaintext highlighter-rouge">df['temperature_2m'].max()</code>) を計算する。</li>
      <li>その結果（数値）を、シンプルなテキストファイル（例: <code class="language-plaintext highlighter-rouge">result.txt</code>）に書き出す処理を追加する。</li>
    </ul>
  </li>
  <li><strong>[C#] (<code class="language-plaintext highlighter-rouge">MainWindow.xaml</code>) の変更:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">StatusTextBlock</code> の上あたりに、解析結果を表示するための <code class="language-plaintext highlighter-rouge">TextBlock</code> (例: <code class="language-plaintext highlighter-rouge">x:Name="AnalysisResultTextBlock"</code>) を追加する。</li>
    </ul>
  </li>
  <li><strong>[C#] (<code class="language-plaintext highlighter-rouge">MainWindow.xaml.cs</code>) の変更:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">RunPythonScriptAsync</code> の実行後（<code class="language-plaintext highlighter-rouge">LoadGraphImage</code> の前）に、<code class="language-plaintext highlighter-rouge">result.txt</code> を<strong>非同期で読み込む</strong> (<code class="language-plaintext highlighter-rouge">File.ReadAllTextAsync</code>) 処理を追加する。</li>
      <li>読み込んだ内容を、新しく追加した <code class="language-plaintext highlighter-rouge">AnalysisResultTextBlock.Text</code> にセットする。</li>
    </ul>
  </li>
</ol>

<h2 id="5-7-コラム-c-7-net-エコシステムの統一">5-7. 【コラム】 C-7: .NET エコシステムの「統一」</h2>

<p>私たちが使ってきた <code class="language-plaintext highlighter-rouge">WPF</code> は、元々 <code class="language-plaintext highlighter-rouge">.NET Framework</code> という、<strong>Windows専用</strong>の環境で動作していました。
一方で、<code class="language-plaintext highlighter-rouge">ASP.NET Core</code>（Web API）などは、<code class="language-plaintext highlighter-rouge">Linux</code> や <code class="language-plaintext highlighter-rouge">macOS</code> でも動く <code class="language-plaintext highlighter-rouge">.NET Core</code> という新しい環境で発展してきました。</p>

<p>かつて、この「Windows専用のFramework」と「マルチプラットフォームのCore」の2つが存在し、C#開発者は「どちらを選べばいいのか」と混乱する時期が長く続きました。</p>

<p><strong>現在は、この問題は解決されています。</strong></p>

<p><code class="language-plaintext highlighter-rouge">Microsoft</code> はこの2つを統合し、<code class="language-plaintext highlighter-rouge">.NET 5</code>、<code class="language-plaintext highlighter-rouge">.NET 6</code>、… <code class="language-plaintext highlighter-rouge">.NET 8</code> (執筆時点の最新安定版) という、<strong>単一の <code class="language-plaintext highlighter-rouge">.NET</code> プラットフォーム</strong>に統一しました。</p>

<ul>
  <li><strong>統一プラットフォーム</strong>: 現代の <code class="language-plaintext highlighter-rouge">.NET</code> は、<code class="language-plaintext highlighter-rouge">ASP.NET Core</code> (Web)、<code class="language-plaintext highlighter-rouge">MAUI</code> (モバイル)、そして私たちが使った <code class="language-plaintext highlighter-rouge">WPF</code> (Windowsデスクトップ) さえもが、同じ一つの基盤の上で動作します。</li>
  <li><strong>クロスプラットフォーム</strong>: <code class="language-plaintext highlighter-rouge">.NET</code> の中核は <code class="language-plaintext highlighter-rouge">Linux</code> や <code class="language-plaintext highlighter-rouge">macOS</code> でも動作します（ただし <code class="language-plaintext highlighter-rouge">WPF</code> のように <code class="language-plaintext highlighter-rouge">Windows</code> のUIに強く依存する部分は <code class="language-plaintext highlighter-rouge">Windows</code> でしか動きません）。</li>
</ul>

<p>瑠璃さんが今学んだC#の知識（<code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>, <code class="language-plaintext highlighter-rouge">HttpClient</code>, <code class="language-plaintext highlighter-rouge">System.Text.Json</code> など）は、<code class="language-plaintext highlighter-rouge">WPF</code> だけでなく、Web API開発（<code class="language-plaintext highlighter-rouge">ASP.NET Core</code>）や、<code class="language-plaintext highlighter-rouge">Unity</code> でのゲーム開発でも、<strong>全く同じように</strong>使える「コアスキル」です。</p>

<h1 id="第6章-おわりに-次のステップへ"><strong>第6章: おわりに (次のステップへ)</strong></h1>

<p>瑠璃さん、このテキストの学習、本当にお疲れ様でした。<br />
第0章でC#の「速度」と「安全性」に関する誤解を解き、Visual Studioをセットアップしてから、第5章でC#とPythonを連携させた「気象APIビューア」を完成させるまで、あなたはC#アプリケーション開発における最も重要で実践的なスキルセットを一通り習得しました。<br />
この最終章では、私たちが共に歩んできた道のりを振り返り、そして瑠璃さんが次に進むべき、C#のさらに広大な世界への道筋を示します。</p>

<h2 id="6-1-概念解説-本テキストで学んだことの総復習"><strong>6-1. 【概念解説】 本テキストで学んだことの総復習</strong></h2>

<p>私たちが構築したアプリケーションは、シンプルながら、現代的なC#アプリケーションの「五大要素」をすべて含んでいます。</p>

<ol>
  <li><strong>C#の基礎 (第1章)</strong>
    <ul>
      <li>class, namespace といったC#の基本構造。</li>
      <li>静的型付け言語の強み（int, double, string）。</li>
      <li>var による型推論。</li>
      <li>List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt; と foreach によるコレクション操作。</li>
    </ul>
  </li>
  <li><strong>堅牢な例外処理 (第2章)</strong>
    <ul>
      <li>try-catch-finally による防御的プログラミング。</li>
      <li>HttpRequestException, JsonException といった実用的な例外の捕捉。</li>
      <li>using 構文による安全なリソース管理。</li>
      <li>ログの重要性。</li>
    </ul>
  </li>
  <li><strong>非同期API通信 (第3章)</strong>
    <ul>
      <li>async/await の概念（フリーズしないUIの鍵）。</li>
      <li>Task と Task&lt;T&gt;（将来の結果の引換券）。</li>
      <li>HttpClient を使ったREST APIの呼び出し。</li>
      <li>System.Text.Json によるJSONのデシリアライズ（オブジェクトへの変換）。</li>
    </ul>
  </li>
  <li><strong>WPFによるGUI (第4章)</strong>
    <ul>
      <li>XAML（見た目）とC#コードビハインド（ロジック）の分離。</li>
      <li>Button, TextBox, TextBlock, Image などの基本コントロール。</li>
      <li>async void イベントハンドラとUIスレッドの「罠」。</li>
    </ul>
  </li>
  <li><strong>異言語連携 (第5章)</strong>
    <ul>
      <li>C#とPythonの「いいとこ取り」をする設計思想。</li>
      <li>Process.Start による外部プロセスの起動と制御。</li>
      <li>ファイル（JSON, PNG）を介した安全なデータ連携。</li>
      <li>BitmapImage のファイルロック問題とその回避策（BitmapCacheOption.OnLoad）。</li>
    </ul>
  </li>
</ol>

<p>このスキルセットは、あなたが今後どのようなC#アプリケーションを作る上でも、強固な基盤となるはずです。</p>

<h2 id="6-2-概念解説-cのさらなる学習分野"><strong>6-2. 【概念解説】 C#のさらなる学習分野</strong></h2>

<p>私たちは今、C#という巨大な世界の「入り口」に立ち、確かな一歩を踏み出したところです。このテキストで学んだ知識を土台に、瑠璃さんは以下の4つの主要な分野に専門性を広げていくことができます。</p>

<h3 id="1-wpfの真髄データバインディング-mvvm"><strong>1. WPFの真髄：データバインディング (MVVM)</strong></h3>

<p>私たちは今回、「コードビハインド」（GetButton_Click など）にロジックを直接記述しました。これは小規模アプリでは直感的ですが、大規模になると XAML と C# が密結合し、テストやメンテナンスが困難になります。</p>

<p>次のステップ: MVVM (Model-View-ViewModel) パターンを学ぶこと。<br />
これは、WPFの真価である**「データバインディング」**を最大限に活用する設計パターンです。<br />
C#側（ViewModel）で string StatusText というプロパティの値を変更するだけで、XAML 側（View）の &lt;TextBlock Text=”{Binding StatusText}”/&gt; が自動的に更新されるようになります。<br />
コードビハインドから ResultTextBlock.Text = “…” のようなUI操作コードを完全に排除でき、ロジックとUIを真に分離できます。</p>

<h3 id="2-データベース連携-entity-framework-core"><strong>2. データベース連携 (Entity Framework Core)</strong></h3>

<p>アプリケーションが取得したデータをローカルに永続化（保存）したくなるのは自然な流れです。SQLite のようなローカルデータベースや、SQL Server のような本格的なデータベースと連携するには <strong>Entity Framework Core (EF Core)</strong> を使います。</p>

<p>次のステップ: EF Core を学ぶこと。<br />
これはC#からデータベースを操作するための標準的な O/R Mapper です。SQL 文を直接書くことなく、C#のオブジェクト（クラス）をそのままデータベースに保存・読み込みできるようになります。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// EF Core を使うと、こんな風にC\#でDBを操作できる  
var weather \= await dbContext.WeatherReadings.FindAsync(id);  
weather.Temperature \= 25.5;  
await dbContext.SaveChangesAsync(); // これだけで UPDATE 文が実行される
</code></pre></div></div>
<h3 id="3-web-api開発-aspnet-core"><strong>3. Web API開発 (ASP.NET Core)</strong></h3>

<p>今回はAPIを「呼び出す側」でしたが、C#はAPIを「作る側（サーバーサイド）」でも非常に強力です。<strong>ASP.NET Core</strong> は、Python の FastAPI や Flask に相当する、C#のWebフレームワークです。</p>

<p>次のステップ: ASP.NET Core を学ぶこと。<br />
ASP.NET Core は世界最速クラスのパフォーマンスを誇り、Linux コンテナ（Docker）での実行も標準です。C# (ASP.NET Core) で書いたAPIを、C# (WPF) や JavaScript (React) から呼び出す、というフルスタック開発が可能になります。</p>

<h3 id="4-ゲーム開発-unity"><strong>4. ゲーム開発 (Unity)</strong></h3>

<p>もしグラフィカルなシミュレーションや、エンターテイメント分野に興味が移った場合、C#は<strong>Unity</strong>の標準スクリプト言語です。</p>

<p>次のステップ: Unity を学ぶこと。<br />
Unity は、世界中のモバイルゲームや VR/AR コンテンツで圧倒的なシェアを誇るゲームエンジンです。このテキストで学んだC#の基礎（class, List, foreach）や async/await の知識は、Unity でゲームオブジェクトを動かすロジックを記述する際に、そのまま活かすことができます。</p>

<h2 id="6-3-瑠璃さんへのメッセージ-あなたの専門分野とc"><strong>6-3. 【瑠璃さんへのメッセージ】 あなたの専門分野とC#</strong></h2>

<p>最後に。なぜ、このテキストの題材が C# (WPF) + Python 連携だったのか。<br />
それは、この構成が瑠璃さんの専攻である機械工学やライフサイエンスの現場で、非常に価値の高いスキルセットだからです。</p>

<ul>
  <li><strong>機械工学（計測・制御）:</strong>
    <ul>
      <li>多くの製造装置、検査装置、センサー（例：Keyence, Omron, National Instruments）は、Windows PCから制御され、そのSDK（ドライバ）は C# や C++ で提供されていることが非常に多いです。</li>
      <li>このテキストで学んだ WPF の技術は、それらの計測機器の**「カスタム制御GUI（ダッシュボード）」**を開発する際に、そのまま使用できます。</li>
      <li>async/await は、センサーからのデータをリアルタイムで処理しつつ、GUIをフリーズさせないために必須の技術です。</li>
    </ul>
  </li>
  <li><strong>ライフサイエンス（データ解析）:</strong>
    <ul>
      <li>研究室では、Python（Pandas, SciPy, BioPython）を使った高度なデータ解析スクリプトが日々実行されています。</li>
      <li>しかし、そのスクリプトを実行するために、研究者が毎回黒い画面（コンソール）でコマンドを打つのは非効率です。</li>
      <li>このテキストで構築した**「C# (WPF) のフロントエンド」<strong>と</strong>「Pythonのバックエンド（解析エンジン）」<strong>を連携させるアーキテクチャは、それらの解析スクリプトを、専門家でない人でもボタン一つで実行・可視化できる</strong>「解析アプリケーション」**として配布する際の、完璧なモデルケースとなります。</li>
    </ul>
  </li>
</ul>

<p>C#は、Windows というプラットフォームと深く結びつき、産業界とアカデミアの「現場」で今も動き続けるシステムを支える、信頼性の高い言語です。</p>

<p>このテキストを通じて、瑠璃さんがC#の「堅牢性」と「開発効率」、そして「広大な可能性」を感じ取ってくれたなら、これ以上の喜びはありません。</p>

<p>あなたのC#学習の旅は、まだ始まったばかりです。<br />
（完）</p>

</article>


        </main>
    </div>

    <!-- フッター（色付き） -->
    <footer class="bg-[#7278a8] text-white mt-8">
        <div class="container mx-auto px-4 md:px-8 py-8 text-center">
            <div class="flex flex-wrap justify-center gap-4 md:gap-6 mb-6">
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/" class="text-white/90 hover:text-white transition-colors">ホーム</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/posts/"
                    class="text-white/90 hover:text-white transition-colors">記事一覧</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/tools/"
                    class="text-white/90 hover:text-white transition-colors">ツール一覧</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/novel/"
                    class="text-white/90 hover:text-white transition-colors">Novel</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/game/"
                    class="text-white/90 hover:text-white transition-colors">Game</a>
                <a href="/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog/contact/"
                    class="text-white/90 hover:text-white transition-colors">お問い合わせ</a>
            </div>
            <div class="mb-4 text-white/80 text-sm space-y-1">
                <p>GitHub: <a
                        href="https://github.com/ruri-sayo/f53cfe5b31cafa1ddb061d46c22a2d5ca41f302bc889dc325f0423744834dd2a_WP_CM_blog"
                        class="text-white hover:underline">ruri-sayo</a></p>
                <p>About us: <a href="https://ruri-sayo.github.io/SSC_site/" class="text-white hover:underline">Sayo
                        Social Connect</a></p>
            </div>
            <p class="text-sm text-white/70">&copy; 2025 <a
                    href="https://ruri-sayo.github.io/SSC_site/" class="hover:underline">Sayo Social Connect</a>. All
                Rights Reserved.</p>
        </div>
    </footer>

    <!-- モバイルナビゲーション用JavaScript -->
    <script>
        (function () {
            const menuBtn = document.getElementById('mobile-menu-btn');
            const menuClose = document.getElementById('mobile-menu-close');
            const menu = document.getElementById('mobile-menu');
            const overlay = document.getElementById('mobile-menu-overlay');

            function openMenu() {
                menu.classList.remove('translate-x-full');
                overlay.classList.remove('hidden');
                menuBtn.setAttribute('aria-expanded', 'true');
                document.body.style.overflow = 'hidden';
            }

            function closeMenu() {
                menu.classList.add('translate-x-full');
                overlay.classList.add('hidden');
                menuBtn.setAttribute('aria-expanded', 'false');
                document.body.style.overflow = '';
            }

            menuBtn.addEventListener('click', openMenu);
            menuClose.addEventListener('click', closeMenu);
            overlay.addEventListener('click', closeMenu);

            // Escキーでメニューを閉じる
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && !menu.classList.contains('translate-x-full')) {
                    closeMenu();
                }
            });
        })();
    </script>
</body>

</html>