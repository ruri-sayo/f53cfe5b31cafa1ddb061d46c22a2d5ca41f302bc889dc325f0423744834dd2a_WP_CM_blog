<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>語尾変換器</title>
    <!-- デザイン用フレームワーク: Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- YAMLパーサー: js-yaml -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        /* カスタムフォントや微調整が必要な場合はここに記述 */
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex flex-col items-center py-10 px-4">

    <!-- Header -->
    <header class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-indigo-600 mb-2">語尾変換器</h1>
        <p class="text-sm text-gray-600">ルールベース変換エンジン</p>
    </header>

    <!-- Main App Container -->
    <main class="w-full max-w-2xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        
        <!-- Error Display -->
        <div id="error-box" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <span class="block sm:inline" id="error-msg">設定ファイルの読み込みに失敗しました。</span>
        </div>

        <!-- Input Section -->
        <div class="mb-6">
            <label for="input-text" class="block text-sm font-medium text-gray-700 mb-2">変換したい文章</label>
            <textarea id="input-text" rows="4" 
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-y"
                placeholder="例：今日はとてもいい天気ですね。明日は暇ですか？"></textarea>
        </div>

        <!-- Settings Section -->
        <div class="mb-6 bg-gray-50 p-4 rounded-lg border border-gray-200">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                
                <!-- Character Select -->
                <div>
                    <label for="char-select" class="block text-sm font-medium text-gray-700 mb-1">キャラクター（語尾）選択</label>
                    <select id="char-select" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white">
                        <option value="" disabled selected>読み込み中...</option>
                    </select>
                </div>

                <!-- Custom Suffix Input (Hidden by default) -->
                <div id="custom-area" class="hidden">
                    <label for="custom-suffix" class="block text-sm font-medium text-gray-700 mb-1">カスタム語尾（指定）</label>
                    <input type="text" id="custom-suffix" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        placeholder="例：ワン">
                    <p class="text-xs text-gray-500 mt-1">※文脈に応じて「ね」「？」を自動補完します</p>
                </div>
            </div>
        </div>

        <!-- Action Button -->
        <div class="mb-6 text-center">
            <button id="convert-btn" 
                class="w-full md:w-auto px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow transition duration-200 flex items-center justify-center mx-auto">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                変換する
            </button>
        </div>

        <!-- Output Section -->
        <div class="mb-2">
            <label for="output-text" class="block text-sm font-medium text-gray-700 mb-2">変換結果</label>
            <textarea id="output-text" rows="4" readonly
                class="w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg focus:outline-none text-gray-800"></textarea>
        </div>

        <!-- Copy Button -->
        <div class="text-right">
            <button id="copy-btn" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium flex items-center justify-end ml-auto">
                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                クリップボードにコピー
            </button>
            <span id="copy-msg" class="text-xs text-green-600 font-bold hidden transition-opacity duration-500">コピーしました！</span>
        </div>
    </main>

    <footer class="mt-8 text-center text-gray-500 text-sm">
        &copy; 2025 SSC.
    </footer>

    <!-- Application Logic -->
    <script>
        // グローバル設定オブジェクト
        let appConfig = null;

        // DOM要素の取得
        const elements = {
            inputText: document.getElementById('input-text'),
            outputText: document.getElementById('output-text'),
            charSelect: document.getElementById('char-select'),
            customArea: document.getElementById('custom-area'),
            customSuffix: document.getElementById('custom-suffix'),
            convertBtn: document.getElementById('convert-btn'),
            copyBtn: document.getElementById('copy-btn'),
            copyMsg: document.getElementById('copy-msg'),
            errorBox: document.getElementById('error-box'),
            errorMsg: document.getElementById('error-msg')
        };

        /**
         * 1. 初期化処理: config.yamlを読み込む
         */
        async function init() {
            try {
                // ローカル環境(file://)でのCORSエラー対策として、相対パスで取得
                // 注意: ブラウザのセキュリティ制約により、ローカルサーバを立てずにfile://で開くとエラーになる場合があります
                const response = await fetch('./config.yaml');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const yamlText = await response.text();
                appConfig = jsyaml.load(yamlText);

                initDropdown();
                attachEventListeners();

            } catch (error) {
                console.error('Config loading failed:', error);
                elements.errorMsg.textContent = `設定ファイル(config.yaml)の読み込みに失敗しました。ローカルサーバー経由で開いているか確認してください。(Error: ${error.message})`;
                elements.errorBox.classList.remove('hidden');
            }
        }

        /**
         * 2. プルダウンの生成
         */
        function initDropdown() {
            elements.charSelect.innerHTML = ''; // 初期化

            // YAMLから読み込んだキャラを追加
            appConfig.characters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.id;
                option.textContent = char.name;
                elements.charSelect.appendChild(option);
            });

            // カスタムオプションの追加
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = 'カスタム（自由入力）';
            elements.charSelect.appendChild(customOption);
        }

        /**
         * 3. イベントリスナーの設定
         */
        function attachEventListeners() {
            // プルダウン変更時
            elements.charSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    elements.customArea.classList.remove('hidden');
                } else {
                    elements.customArea.classList.add('hidden');
                }
            });

            // 変換ボタン押下時
            elements.convertBtn.addEventListener('click', convertText);

            // コピーボタン押下時
            elements.copyBtn.addEventListener('click', copyToClipboard);
        }

        /**
         * 4. 変換ロジック (Core Logic)
         */
        function convertText() {
            if (!appConfig) return;

            const text = elements.inputText.value;
            const selectedId = elements.charSelect.value;
            
            // 選択されたキャラの定義を取得
            let charDef = appConfig.characters.find(c => c.id === selectedId);
            const isCustom = (selectedId === 'custom');
            const customVal = elements.customSuffix.value.trim();

            // 正規表現オブジェクトの生成 (毎回生成しないよう最適化も可能だが、今回は可読性重視)
            // YAMLの文字列からRegExpオブジェクトを作る
            const patterns = {
                agreement: new RegExp(appConfig.patterns.agreement),
                question: new RegExp(appConfig.patterns.question),
                normal: new RegExp(appConfig.patterns.normal)
            };

            // 行ごとに処理
            const lines = text.split('\n');
            const convertedLines = lines.map(line => {
                // 空行はスキップ
                if (!line.trim()) return line;

                let type = 'normal';
                let stem = line;

                // A. 同意 (Agreement) 判定
                if (patterns.agreement.test(line)) {
                    type = 'agreement';
                    stem = line.replace(patterns.agreement, '');
                } 
                // B. 疑問 (Question) 判定
                else if (patterns.question.test(line)) {
                    type = 'question';
                    stem = line.replace(patterns.question, '');
                } 
                // C. 通常 (Normal) 判定
                else {
                    type = 'normal';
                    // 通常パターンの語尾（丁寧語など）があれば除去
                    if (patterns.normal.test(line)) {
                        stem = line.replace(patterns.normal, '');
                    }
                }

                // 語尾の決定
                let suffix = '';
                if (isCustom) {
                    // カスタム時の簡易自動補完ルール
                    if (type === 'agreement') suffix = `${customVal}ね`;
                    else if (type === 'question') suffix = `${customVal}？`;
                    else suffix = customVal;
                } else {
                    // プリセットキャラのルール適用
                    suffix = charDef.suffixes[type];
                }

                return stem + suffix;
            });

            elements.outputText.value = convertedLines.join('\n');
        }

        /**
         * 5. クリップボードコピー
         */
        function copyToClipboard() {
            const text = elements.outputText.value;
            if (!text) return;

            navigator.clipboard.writeText(text).then(() => {
                elements.copyMsg.classList.remove('hidden');
                setTimeout(() => {
                    elements.copyMsg.classList.add('hidden');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed', err);
            });
        }

        // アプリ起動
        window.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>